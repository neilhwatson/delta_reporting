.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Reactor 3"
.TH Mojo::Reactor 3 "2014-02-26" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Reactor \- Low level event reactor base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Mojo::Reactor::MyEventLoop;
\&  use Mojo::Base \*(AqMojo::Reactor\*(Aq;
\&
\&  $ENV{MOJO_REACTOR} ||= \*(AqMojo::Reactor::MyEventLoop\*(Aq;
\&
\&  sub again      {...}
\&  sub io         {...}
\&  sub is_running {...}
\&  sub one_tick   {...}
\&  sub recurring  {...}
\&  sub remove     {...}
\&  sub start      {...}
\&  sub stop       {...}
\&  sub timer      {...}
\&  sub watch      {...}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Reactor is an abstract base class for low level event reactors.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::Reactor inherits all events from Mojo::EventEmitter and can emit
the following new ones.
.SS "error"
.IX Subsection "error"
.Vb 4
\&  $reactor\->on(error => sub {
\&    my ($reactor, $err) = @_;
\&    ...
\&  });
.Ve
.PP
Emitted for exceptions caught in callbacks, fatal if unhandled. Note that if
this event is unhandled or fails it might kill your program, so you need to be
careful.
.PP
.Vb 4
\&  $reactor\->on(error => sub {
\&    my ($reactor, $err) = @_;
\&    say "Something very bad happened: $err";
\&  });
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojo::Reactor inherits all methods from Mojo::EventEmitter and
implements the following new ones.
.SS "again"
.IX Subsection "again"
.Vb 1
\&  $reactor\->again($id);
.Ve
.PP
Restart active timer. Meant to be overloaded in a subclass.
.SS "detect"
.IX Subsection "detect"
.Vb 1
\&  my $class = Mojo::Reactor\->detect;
.Ve
.PP
Detect and load the best reactor implementation available, will try the value
of the \s-1MOJO_REACTOR\s0 environment variable, Mojo::Reactor::EV or
Mojo::Reactor::Poll.
.PP
.Vb 2
\&  # Instantiate best reactor implementation available
\&  my $reactor = Mojo::Reactor\->detect\->new;
.Ve
.SS "io"
.IX Subsection "io"
.Vb 1
\&  $reactor = $reactor\->io($handle => sub {...});
.Ve
.PP
Watch handle for I/O events, invoking the callback whenever handle becomes
readable or writable. Meant to be overloaded in a subclass.
.PP
.Vb 5
\&  # Callback will be invoked twice if handle becomes readable and writable
\&  $reactor\->io($handle => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqHandle is writable\*(Aq : \*(AqHandle is readable\*(Aq;
\&  });
.Ve
.SS "is_readable"
.IX Subsection "is_readable"
.Vb 1
\&  my $bool = $reactor\->is_readable($handle);
.Ve
.PP
Quick non-blocking check if a handle is readable, useful for identifying
tainted sockets.
.SS "is_running"
.IX Subsection "is_running"
.Vb 1
\&  my $bool = $reactor\->is_running;
.Ve
.PP
Check if reactor is running. Meant to be overloaded in a subclass.
.SS "next_tick"
.IX Subsection "next_tick"
.Vb 1
\&  my $undef = $reactor\->next_tick(sub {...});
.Ve
.PP
Invoke callback as soon as possible, but not before returning, always returns
\&\f(CW\*(C`undef\*(C'\fR.
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 1
\&  $reactor\->one_tick;
.Ve
.PP
Run reactor until an event occurs. Note that this method can recurse back into
the reactor, so you need to be careful. Meant to be overloaded in a subclass.
.PP
.Vb 4
\&  # Don\*(Aqt block longer than 0.5 seconds
\&  my $id = $reactor\->timer(0.5 => sub {});
\&  $reactor\->one_tick;
\&  $reactor\->remove($id);
.Ve
.SS "recurring"
.IX Subsection "recurring"
.Vb 1
\&  my $id = $reactor\->recurring(0.25 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds. Meant to be overloaded in a subclass.
.SS "remove"
.IX Subsection "remove"
.Vb 2
\&  my $bool = $reactor\->remove($handle);
\&  my $bool = $reactor\->remove($id);
.Ve
.PP
Remove handle or timer. Meant to be overloaded in a subclass.
.SS "start"
.IX Subsection "start"
.Vb 1
\&  $reactor\->start;
.Ve
.PP
Start watching for I/O and timer events, this will block until \*(L"stop\*(R" is
called. Note that some reactors stop automatically if there are no events
being watched anymore. Meant to be overloaded in a subclass.
.SS "stop"
.IX Subsection "stop"
.Vb 1
\&  $reactor\->stop;
.Ve
.PP
Stop watching for I/O and timer events. Meant to be overloaded in a subclass.
.SS "timer"
.IX Subsection "timer"
.Vb 1
\&  my $id = $reactor\->timer(0.5 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds. Meant to be overloaded in a subclass.
.SS "watch"
.IX Subsection "watch"
.Vb 1
\&  $reactor = $reactor\->watch($handle, $readable, $writable);
.Ve
.PP
Change I/O events to watch handle for with true and false values. Meant to be
overloaded in a subclass. Note that this method requires an active I/O
watcher.
.PP
.Vb 2
\&  # Watch only for readable events
\&  $reactor\->watch($handle, 1, 0);
\&
\&  # Watch only for writable events
\&  $reactor\->watch($handle, 0, 1);
\&
\&  # Watch for readable and writable events
\&  $reactor\->watch($handle, 1, 1);
\&
\&  # Pause watching for events
\&  $reactor\->watch($handle, 0, 0);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
