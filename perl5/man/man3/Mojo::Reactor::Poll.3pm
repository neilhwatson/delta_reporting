.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Reactor::Poll 3"
.TH Mojo::Reactor::Poll 3 "2015-02-27" "perl v5.20.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Reactor::Poll \- Low\-level event reactor with poll support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Reactor::Poll;
\&
\&  # Watch if handle becomes readable or writable
\&  my $reactor = Mojo::Reactor::Poll\->new;
\&  $reactor\->io($first => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqFirst handle is writable\*(Aq : \*(AqFirst handle is readable\*(Aq;
\&  });
\&
\&  # Change to watching only if handle becomes writable
\&  $reactor\->watch($first, 0, 1);
\&
\&  # Turn file descriptor into handle and watch if it becomes readable
\&  my $second = IO::Handle\->new_from_fd($fd, \*(Aqr\*(Aq);
\&  $reactor\->io($second => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqSecond handle is writable\*(Aq : \*(AqSecond handle is readable\*(Aq;
\&  })\->watch($second, 1, 0);
\&
\&  # Add a timer
\&  $reactor\->timer(15 => sub {
\&    my $reactor = shift;
\&    $reactor\->remove($first);
\&    $reactor\->remove($second);
\&    say \*(AqTimeout!\*(Aq;
\&  });
\&
\&  # Start reactor if necessary
\&  $reactor\->start unless $reactor\->is_running;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Reactor::Poll is a low-level event reactor based on IO::Poll.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::Reactor::Poll inherits all events from Mojo::Reactor.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Reactor::Poll inherits all methods from Mojo::Reactor and
implements the following new ones.
.SS "again"
.IX Subsection "again"
.Vb 1
\&  $reactor\->again($id);
.Ve
.PP
Restart active timer.
.SS "io"
.IX Subsection "io"
.Vb 1
\&  $reactor = $reactor\->io($handle => sub {...});
.Ve
.PP
Watch handle for I/O events, invoking the callback whenever handle becomes
readable or writable.
.SS "is_running"
.IX Subsection "is_running"
.Vb 1
\&  my $bool = $reactor\->is_running;
.Ve
.PP
Check if reactor is running.
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 1
\&  $reactor\->one_tick;
.Ve
.PP
Run reactor until an event occurs or no events are being watched anymore. Note
that this method can recurse back into the reactor, so you need to be careful.
.SS "recurring"
.IX Subsection "recurring"
.Vb 1
\&  my $id = $reactor\->recurring(0.25 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds.
.SS "remove"
.IX Subsection "remove"
.Vb 2
\&  my $bool = $reactor\->remove($handle);
\&  my $bool = $reactor\->remove($id);
.Ve
.PP
Remove handle or timer.
.SS "reset"
.IX Subsection "reset"
.Vb 1
\&  $reactor\->reset;
.Ve
.PP
Remove all handles and timers.
.SS "start"
.IX Subsection "start"
.Vb 1
\&  $reactor\->start;
.Ve
.PP
Start watching for I/O and timer events, this will block until \*(L"stop\*(R" is
called or no events are being watched anymore.
.SS "stop"
.IX Subsection "stop"
.Vb 1
\&  $reactor\->stop;
.Ve
.PP
Stop watching for I/O and timer events.
.SS "timer"
.IX Subsection "timer"
.Vb 1
\&  my $id = $reactor\->timer(0.5 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds.
.SS "watch"
.IX Subsection "watch"
.Vb 1
\&  $reactor = $reactor\->watch($handle, $readable, $writable);
.Ve
.PP
Change I/O events to watch handle for with true and false values. Note that
this method requires an active I/O watcher.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
