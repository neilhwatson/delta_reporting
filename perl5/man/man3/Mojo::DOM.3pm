.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.30)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::DOM 3"
.TH Mojo::DOM 3 "2015-07-03" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::DOM \- Minimalistic HTML/XML DOM parser with CSS selectors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::DOM;
\&
\&  # Parse
\&  my $dom = Mojo::DOM\->new(\*(Aq<div><p id="a">Test</p><p id="b">123</p></div>\*(Aq);
\&
\&  # Find
\&  say $dom\->at(\*(Aq#b\*(Aq)\->text;
\&  say $dom\->find(\*(Aqp\*(Aq)\->map(\*(Aqtext\*(Aq)\->join("\en");
\&  say $dom\->find(\*(Aq[id]\*(Aq)\->map(attr => \*(Aqid\*(Aq)\->join("\en");
\&
\&  # Iterate
\&  $dom\->find(\*(Aqp[id]\*(Aq)\->reverse\->each(sub { say $_\->{id} });
\&
\&  # Loop
\&  for my $e ($dom\->find(\*(Aqp[id]\*(Aq)\->each) {
\&    say $e\->{id}, \*(Aq:\*(Aq, $e\->text;
\&  }
\&
\&  # Modify
\&  $dom\->find(\*(Aqdiv p\*(Aq)\->last\->append(\*(Aq<p id="c">456</p>\*(Aq);
\&  $dom\->find(\*(Aq:not(p)\*(Aq)\->map(\*(Aqstrip\*(Aq);
\&
\&  # Render
\&  say "$dom";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::DOM is a minimalistic and relaxed \s-1HTML/XML DOM\s0 parser with \s-1CSS\s0
selector support. It will even try to interpret broken \s-1HTML\s0 and \s-1XML,\s0 so you
should not use it for validation.
.SH "CASE-SENSITIVITY"
.IX Header "CASE-SENSITIVITY"
Mojo::DOM defaults to \s-1HTML\s0 semantics, that means all tags and attribute
names are lowercased and selectors need to be lowercase as well.
.PP
.Vb 2
\&  my $dom = Mojo::DOM\->new(\*(Aq<P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(Aqp[id]\*(Aq)\->text;
.Ve
.PP
If \s-1XML\s0 processing instructions are found, the parser will automatically switch
into \s-1XML\s0 mode and everything becomes case-sensitive.
.PP
.Vb 2
\&  my $dom = Mojo::DOM\->new(\*(Aq<?xml version="1.0"?><P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(AqP[ID]\*(Aq)\->text;
.Ve
.PP
\&\s-1XML\s0 detection can also be disabled with the \*(L"xml\*(R" method.
.PP
.Vb 2
\&  # Force XML semantics
\&  $dom\->xml(1);
\&
\&  # Force HTML semantics
\&  $dom\->xml(0);
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojo::DOM implements the following methods.
.SS "all_text"
.IX Subsection "all_text"
.Vb 2
\&  my $trimmed   = $dom\->all_text;
\&  my $untrimmed = $dom\->all_text(0);
.Ve
.PP
Extract text content from all descendant nodes of this element, smart
whitespace trimming is enabled by default.
.PP
.Vb 2
\&  # "foo bar baz"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->at(\*(Aqdiv\*(Aq)\->all_text;
\&
\&  # "foo\enbarbaz\en"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->at(\*(Aqdiv\*(Aq)\->all_text(0);
.Ve
.SS "ancestors"
.IX Subsection "ancestors"
.Vb 2
\&  my $collection = $dom\->ancestors;
\&  my $collection = $dom\->ancestors(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all ancestor elements of this node matching the \s-1CSS\s0 selector and return a
Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # List tag names of ancestor elements
\&  say $dom\->ancestors\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS "append"
.IX Subsection "append"
.Vb 1
\&  $dom = $dom\->append(\*(Aq<p>I ♥ Mojolicious!</p>\*(Aq);
.Ve
.PP
Append \s-1HTML/XML\s0 fragment to this node.
.PP
.Vb 3
\&  # "<div><h1>Test</h1><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)
\&    \->at(\*(Aqh1\*(Aq)\->append(\*(Aq<h2>123</h2>\*(Aq)\->root;
\&
\&  # "<p>Test 123</p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)
\&    \->child_nodes\->first\->append(\*(Aq 123\*(Aq)\->root;
.Ve
.SS "append_content"
.IX Subsection "append_content"
.Vb 1
\&  $dom = $dom\->append_content(\*(Aq<p>I ♥ Mojolicious!</p>\*(Aq);
.Ve
.PP
Append \s-1HTML/XML\s0 fragment (for \f(CW\*(C`root\*(C'\fR and \f(CW\*(C`tag\*(C'\fR nodes) or raw content to this
node's content.
.PP
.Vb 3
\&  # "<div><h1>Test123</h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)
\&    \->at(\*(Aqh1\*(Aq)\->append_content(\*(Aq123\*(Aq)\->root;
\&
\&  # "<!\-\- Test 123 \-\-><br>"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><br>\*(Aq)
\&    \->child_nodes\->first\->append_content(\*(Aq123 \*(Aq)\->root;
\&
\&  # "<p>Test<i>123</i></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->append_content(\*(Aq<i>123</i>\*(Aq)\->root;
.Ve
.SS "at"
.IX Subsection "at"
.Vb 1
\&  my $result = $dom\->at(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find first descendant element of this element matching the \s-1CSS\s0 selector and
return it as a Mojo::DOM object or return \f(CW\*(C`undef\*(C'\fR if none could be found.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # Find first element with "svg" namespace definition
\&  my $namespace = $dom\->at(\*(Aq[xmlns\e:svg]\*(Aq)\->{\*(Aqxmlns:svg\*(Aq};
.Ve
.SS "attr"
.IX Subsection "attr"
.Vb 4
\&  my $hash = $dom\->attr;
\&  my $foo  = $dom\->attr(\*(Aqfoo\*(Aq);
\&  $dom     = $dom\->attr({foo => \*(Aqbar\*(Aq});
\&  $dom     = $dom\->attr(foo => \*(Aqbar\*(Aq);
.Ve
.PP
This element's attributes.
.PP
.Vb 2
\&  # List id attributes
\&  say $dom\->find(\*(Aq*\*(Aq)\->map(attr => \*(Aqid\*(Aq)\->compact\->join("\en");
.Ve
.SS "child_nodes"
.IX Subsection "child_nodes"
.Vb 1
\&  my $collection = $dom\->child_nodes;
.Ve
.PP
Return a Mojo::Collection object containing all child nodes of this element
as Mojo::DOM objects.
.PP
.Vb 2
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p>Test<b>123</b></p>\*(Aq)\->at(\*(Aqp\*(Aq)\->child_nodes\->first\->remove;
\&
\&  # "<!\-\- Test \-\->"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><b>123</b>\*(Aq)\->child_nodes\->first;
.Ve
.SS "children"
.IX Subsection "children"
.Vb 2
\&  my $collection = $dom\->children;
\&  my $collection = $dom\->children(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all child elements of this element matching the \s-1CSS\s0 selector and return a
Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # Show tag name of random child element
\&  say $dom\->children\->shuffle\->first\->tag;
.Ve
.SS "content"
.IX Subsection "content"
.Vb 2
\&  my $str = $dom\->content;
\&  $dom    = $dom\->content(\*(Aq<p>I ♥ Mojolicious!</p>\*(Aq);
.Ve
.PP
Return this node's content or replace it with \s-1HTML/XML\s0 fragment (for \f(CW\*(C`root\*(C'\fR
and \f(CW\*(C`tag\*(C'\fR nodes) or raw content.
.PP
.Vb 2
\&  # "<b>Test</b>"
\&  $dom\->parse(\*(Aq<div><b>Test</b></div>\*(Aq)\->at(\*(Aqdiv\*(Aq)\->content;
\&
\&  # "<div><h1>123</h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->content(\*(Aq123\*(Aq)\->root;
\&
\&  # "<p><i>123</i></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->content(\*(Aq<i>123</i>\*(Aq)\->root;
\&
\&  # "<div><h1></h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->content(\*(Aq\*(Aq)\->root;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><br>\*(Aq)\->child_nodes\->first\->content;
\&
\&  # "<div><!\-\- 123 \-\->456</div>"
\&  $dom\->parse(\*(Aq<div><!\-\- Test \-\->456</div>\*(Aq)
\&    \->at(\*(Aqdiv\*(Aq)\->child_nodes\->first\->content(\*(Aq 123 \*(Aq)\->root;
.Ve
.SS "descendant_nodes"
.IX Subsection "descendant_nodes"
.Vb 1
\&  my $collection = $dom\->descendant_nodes;
.Ve
.PP
Return a Mojo::Collection object containing all descendant nodes of this
element as Mojo::DOM objects.
.PP
.Vb 4
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p><!\-\- Test \-\-><b>123<!\-\- 456 \-\-></b></p>\*(Aq)
\&    \->descendant_nodes\->grep(sub { $_\->type eq \*(Aqcomment\*(Aq })
\&    \->map(\*(Aqremove\*(Aq)\->first;
\&
\&  # "<p><b>test</b>test</p>"
\&  $dom\->parse(\*(Aq<p><b>123</b>456</p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->descendant_nodes\->grep(sub { $_\->type eq \*(Aqtext\*(Aq })
\&    \->map(content => \*(Aqtest\*(Aq)\->first\->root;
.Ve
.SS "find"
.IX Subsection "find"
.Vb 1
\&  my $collection = $dom\->find(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all descendant elements of this element matching the \s-1CSS\s0 selector and
return a Mojo::Collection object containing these elements as Mojo::DOM
objects. All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # Find a specific element and extract information
\&  my $id = $dom\->find(\*(Aqdiv\*(Aq)\->[23]{id};
\&
\&  # Extract information from multiple elements
\&  my @headers = $dom\->find(\*(Aqh1, h2, h3\*(Aq)\->map(\*(Aqtext\*(Aq)\->each;
\&
\&  # Count all the different tags
\&  my $hash = $dom\->find(\*(Aq*\*(Aq)\->reduce(sub { $a\->{$b\->tag}++; $a }, {});
\&
\&  # Find elements with a class that contains dots
\&  my @divs = $dom\->find(\*(Aqdiv.foo\e.bar\*(Aq)\->each;
.Ve
.SS "following"
.IX Subsection "following"
.Vb 2
\&  my $collection = $dom\->following;
\&  my $collection = $dom\->following(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all sibling elements after this node matching the \s-1CSS\s0 selector and return
a Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # List tags of sibling elements after this node
\&  say $dom\->following\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS "following_nodes"
.IX Subsection "following_nodes"
.Vb 1
\&  my $collection = $dom\->following_nodes;
.Ve
.PP
Return a Mojo::Collection object containing all sibling nodes after this
node as Mojo::DOM objects.
.PP
.Vb 2
\&  # "C"
\&  $dom\->parse(\*(Aq<p>A</p><!\-\- B \-\->C\*(Aq)\->at(\*(Aqp\*(Aq)\->following_nodes\->last\->content;
.Ve
.SS "matches"
.IX Subsection "matches"
.Vb 1
\&  my $bool = $dom\->matches(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Check if this element matches the \s-1CSS\s0 selector. All selectors from
\&\*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 3
\&  # True
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aq.a\*(Aq);
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aqp[class]\*(Aq);
\&
\&  # False
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aq.b\*(Aq);
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aqp[id]\*(Aq);
.Ve
.SS "namespace"
.IX Subsection "namespace"
.Vb 1
\&  my $namespace = $dom\->namespace;
.Ve
.PP
Find this element's namespace or return \f(CW\*(C`undef\*(C'\fR if none could be found.
.PP
.Vb 2
\&  # Find namespace for an element with namespace prefix
\&  my $namespace = $dom\->at(\*(Aqsvg > svg\e:circle\*(Aq)\->namespace;
\&
\&  # Find namespace for an element that may or may not have a namespace prefix
\&  my $namespace = $dom\->at(\*(Aqsvg > circle\*(Aq)\->namespace;
.Ve
.SS "new"
.IX Subsection "new"
.Vb 2
\&  my $dom = Mojo::DOM\->new;
\&  my $dom = Mojo::DOM\->new(\*(Aq<foo bar="baz">I ♥ Mojolicious!</foo>\*(Aq);
.Ve
.PP
Construct a new scalar-based Mojo::DOM object and \*(L"parse\*(R" \s-1HTML/XML\s0
fragment if necessary.
.SS "next"
.IX Subsection "next"
.Vb 1
\&  my $sibling = $dom\->next;
.Ve
.PP
Return Mojo::DOM object for next sibling element or \f(CW\*(C`undef\*(C'\fR if there are no
more siblings.
.PP
.Vb 2
\&  # "<h2>123</h2>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1><h2>123</h2></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->next;
.Ve
.SS "next_node"
.IX Subsection "next_node"
.Vb 1
\&  my $sibling = $dom\->next_node;
.Ve
.PP
Return Mojo::DOM object for next sibling node or \f(CW\*(C`undef\*(C'\fR if there are no
more siblings.
.PP
.Vb 3
\&  # "456"
\&  $dom\->parse(\*(Aq<p><b>123</b><!\-\- Test \-\->456</p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->next_node\->next_node;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<p><b>123</b><!\-\- Test \-\->456</p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->next_node\->content;
.Ve
.SS "parent"
.IX Subsection "parent"
.Vb 1
\&  my $parent = $dom\->parent;
.Ve
.PP
Return Mojo::DOM object for parent of this node or \f(CW\*(C`undef\*(C'\fR if this node has
no parent.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $dom = $dom\->parse(\*(Aq<foo bar="baz">I ♥ Mojolicious!</foo>\*(Aq);
.Ve
.PP
Parse \s-1HTML/XML\s0 fragment with Mojo::DOM::HTML.
.PP
.Vb 2
\&  # Parse XML
\&  my $dom = Mojo::DOM\->new\->xml(1)\->parse($xml);
.Ve
.SS "preceding"
.IX Subsection "preceding"
.Vb 2
\&  my $collection = $dom\->preceding;
\&  my $collection = $dom\->preceding(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all sibling elements before this node matching the \s-1CSS\s0 selector and return
a Mojo::Collection object containing these elements as Mojo::DOM objects.
All selectors from \*(L"\s-1SELECTORS\*(R"\s0 in Mojo::DOM::CSS are supported.
.PP
.Vb 2
\&  # List tags of sibling elements before this node
\&  say $dom\->preceding\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS "preceding_nodes"
.IX Subsection "preceding_nodes"
.Vb 1
\&  my $collection = $dom\->preceding_nodes;
.Ve
.PP
Return a Mojo::Collection object containing all sibling nodes before this
node as Mojo::DOM objects.
.PP
.Vb 2
\&  # "A"
\&  $dom\->parse(\*(AqA<!\-\- B \-\-><p>C</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->preceding_nodes\->first\->content;
.Ve
.SS "prepend"
.IX Subsection "prepend"
.Vb 1
\&  $dom = $dom\->prepend(\*(Aq<p>I ♥ Mojolicious!</p>\*(Aq);
.Ve
.PP
Prepend \s-1HTML/XML\s0 fragment to this node.
.PP
.Vb 3
\&  # "<div><h1>Test</h1><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h2>123</h2></div>\*(Aq)
\&    \->at(\*(Aqh2\*(Aq)\->prepend(\*(Aq<h1>Test</h1>\*(Aq)\->root;
\&
\&  # "<p>Test 123</p>"
\&  $dom\->parse(\*(Aq<p>123</p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->child_nodes\->first\->prepend(\*(AqTest \*(Aq)\->root;
.Ve
.SS "prepend_content"
.IX Subsection "prepend_content"
.Vb 1
\&  $dom = $dom\->prepend_content(\*(Aq<p>I ♥ Mojolicious!</p>\*(Aq);
.Ve
.PP
Prepend \s-1HTML/XML\s0 fragment (for \f(CW\*(C`root\*(C'\fR and \f(CW\*(C`tag\*(C'\fR nodes) or raw content to this
node's content.
.PP
.Vb 3
\&  # "<div><h2>Test123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h2>123</h2></div>\*(Aq)
\&    \->at(\*(Aqh2\*(Aq)\->prepend_content(\*(AqTest\*(Aq)\->root;
\&
\&  # "<!\-\- Test 123 \-\-><br>"
\&  $dom\->parse(\*(Aq<!\-\- 123 \-\-><br>\*(Aq)
\&    \->child_nodes\->first\->prepend_content(\*(Aq Test\*(Aq)\->root;
\&
\&  # "<p><i>123</i>Test</p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->prepend_content(\*(Aq<i>123</i>\*(Aq)\->root;
.Ve
.SS "previous"
.IX Subsection "previous"
.Vb 1
\&  my $sibling = $dom\->previous;
.Ve
.PP
Return Mojo::DOM object for previous sibling element or \f(CW\*(C`undef\*(C'\fR if there
are no more siblings.
.PP
.Vb 2
\&  # "<h1>Test</h1>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1><h2>123</h2></div>\*(Aq)\->at(\*(Aqh2\*(Aq)\->previous;
.Ve
.SS "previous_node"
.IX Subsection "previous_node"
.Vb 1
\&  my $sibling = $dom\->previous_node;
.Ve
.PP
Return Mojo::DOM object for previous sibling node or \f(CW\*(C`undef\*(C'\fR if there are
no more siblings.
.PP
.Vb 3
\&  # "123"
\&  $dom\->parse(\*(Aq<p>123<!\-\- Test \-\-><b>456</b></p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->previous_node\->previous_node;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<p>123<!\-\- Test \-\-><b>456</b></p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->previous_node\->content;
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 1
\&  my $parent = $dom\->remove;
.Ve
.PP
Remove this node and return \*(L"parent\*(R".
.PP
.Vb 2
\&  # "<div></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->remove;
\&
\&  # "<p><b>456</b></p>"
\&  $dom\->parse(\*(Aq<p>123<b>456</b></p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->child_nodes\->first\->remove\->root;
.Ve
.SS "replace"
.IX Subsection "replace"
.Vb 1
\&  my $parent = $dom\->replace(\*(Aq<div>I ♥ Mojolicious!</div>\*(Aq);
.Ve
.PP
Replace this node with \s-1HTML/XML\s0 fragment and return \*(L"parent\*(R".
.PP
.Vb 2
\&  # "<div><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->replace(\*(Aq<h2>123</h2>\*(Aq);
\&
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->child_nodes\->[0]\->replace(\*(Aq<b>123</b>\*(Aq)\->root;
.Ve
.SS "root"
.IX Subsection "root"
.Vb 1
\&  my $root = $dom\->root;
.Ve
.PP
Return Mojo::DOM object for root node.
.SS "strip"
.IX Subsection "strip"
.Vb 1
\&  my $parent = $dom\->strip;
.Ve
.PP
Remove this element while preserving its content and return \*(L"parent\*(R".
.PP
.Vb 2
\&  # "<div>Test</div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->strip;
.Ve
.SS "tag"
.IX Subsection "tag"
.Vb 2
\&  my $tag = $dom\->tag;
\&  $dom    = $dom\->tag(\*(Aqdiv\*(Aq);
.Ve
.PP
This element's tag name.
.PP
.Vb 2
\&  # List tag names of child elements
\&  say $dom\->children\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS "tap"
.IX Subsection "tap"
.Vb 1
\&  $dom = $dom\->tap(sub {...});
.Ve
.PP
Alias for \*(L"tap\*(R" in Mojo::Base.
.SS "text"
.IX Subsection "text"
.Vb 2
\&  my $trimmed   = $dom\->text;
\&  my $untrimmed = $dom\->text(0);
.Ve
.PP
Extract text content from this element only (not including child elements),
smart whitespace trimming is enabled by default.
.PP
.Vb 2
\&  # "foo baz"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->at(\*(Aqdiv\*(Aq)\->text;
\&
\&  # "foo\enbaz\en"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->at(\*(Aqdiv\*(Aq)\->text(0);
.Ve
.SS "to_string"
.IX Subsection "to_string"
.Vb 1
\&  my $str = $dom\->to_string;
.Ve
.PP
Render this node and its content to \s-1HTML/XML.\s0
.PP
.Vb 2
\&  # "<b>Test</b>"
\&  $dom\->parse(\*(Aq<div><b>Test</b></div>\*(Aq)\->at(\*(Aqdiv b\*(Aq)\->to_string;
.Ve
.SS "tree"
.IX Subsection "tree"
.Vb 2
\&  my $tree = $dom\->tree;
\&  $dom     = $dom\->tree([\*(Aqroot\*(Aq]);
.Ve
.PP
Document Object Model. Note that this structure should only be used very
carefully since it is very dynamic.
.SS "type"
.IX Subsection "type"
.Vb 1
\&  my $type = $dom\->type;
.Ve
.PP
This node's type, usually \f(CW\*(C`cdata\*(C'\fR, \f(CW\*(C`comment\*(C'\fR, \f(CW\*(C`doctype\*(C'\fR, \f(CW\*(C`pi\*(C'\fR, \f(CW\*(C`raw\*(C'\fR,
\&\f(CW\*(C`root\*(C'\fR, \f(CW\*(C`tag\*(C'\fR or \f(CW\*(C`text\*(C'\fR.
.SS "wrap"
.IX Subsection "wrap"
.Vb 1
\&  $dom = $dom\->wrap(\*(Aq<div></div>\*(Aq);
.Ve
.PP
Wrap \s-1HTML/XML\s0 fragment around this node, placing it as the last child of the
first innermost element.
.PP
.Vb 2
\&  # "<p>123<b>Test</b></p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<p>123</p>\*(Aq)\->root;
\&
\&  # "<div><p><b>Test</b></p>123</div>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<div><p></p>123</div>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p><p>123</p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<p></p><p>123</p>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->child_nodes\->first\->wrap(\*(Aq<b>\*(Aq)\->root;
.Ve
.SS "wrap_content"
.IX Subsection "wrap_content"
.Vb 1
\&  $dom = $dom\->wrap_content(\*(Aq<div></div>\*(Aq);
.Ve
.PP
Wrap \s-1HTML/XML\s0 fragment around this node's content, placing it as the last
children of the first innermost element.
.PP
.Vb 2
\&  # "<p><b>123Test</b></p>"
\&  $dom\->parse(\*(Aq<p>Test<p>\*(Aq)\->at(\*(Aqp\*(Aq)\->wrap_content(\*(Aq<b>123</b>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p><p>123</p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->wrap_content(\*(Aq<p></p><p>123</p>\*(Aq);
.Ve
.SS "xml"
.IX Subsection "xml"
.Vb 2
\&  my $bool = $dom\->xml;
\&  $dom     = $dom\->xml($bool);
.Ve
.PP
Disable \s-1HTML\s0 semantics in parser and activate case-sensitivity, defaults to
auto detection based on processing instructions.
.SH "OPERATORS"
.IX Header "OPERATORS"
Mojo::DOM overloads the following operators.
.SS "array"
.IX Subsection "array"
.Vb 1
\&  my @nodes = @$dom;
.Ve
.PP
Alias for \*(L"child_nodes\*(R".
.PP
.Vb 2
\&  # "<!\-\- Test \-\->"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><b>123</b>\*(Aq)\->[0];
.Ve
.SS "bool"
.IX Subsection "bool"
.Vb 1
\&  my $bool = !!$dom;
.Ve
.PP
Always true.
.SS "hash"
.IX Subsection "hash"
.Vb 1
\&  my %attrs = %$dom;
.Ve
.PP
Alias for \*(L"attr\*(R".
.PP
.Vb 2
\&  # "test"
\&  $dom\->parse(\*(Aq<div id="test">Test</div>\*(Aq)\->at(\*(Aqdiv\*(Aq)\->{id};
.Ve
.SS "stringify"
.IX Subsection "stringify"
.Vb 1
\&  my $str = "$dom";
.Ve
.PP
Alias for \*(L"to_string\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
