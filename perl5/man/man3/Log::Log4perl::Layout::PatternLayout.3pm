.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.30)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Layout::PatternLayout 3"
.TH Layout::PatternLayout 3 "2014-10-28" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Log4perl::Layout::PatternLayout \- Pattern Layout
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Log::Log4perl::Layout::PatternLayout;
\&
\&  my $layout = Log::Log4perl::Layout::PatternLayout\->new(
\&                                                   "%d (%F:%L)> %m");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Creates a pattern layout according to
http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/PatternLayout.html
and a couple of Log::Log4perl\-specific extensions.
.PP
The \f(CW\*(C`new()\*(C'\fR method creates a new PatternLayout, specifying its log
format. The format
string can contain a number of placeholders which will be
replaced by the logging engine when it's time to log the message:
.PP
.Vb 10
\&    %c Category of the logging event.
\&    %C Fully qualified package (or class) name of the caller
\&    %d Current date in yyyy/MM/dd hh:mm:ss format
\&    %d{...} Current date in customized format (see below)
\&    %F File where the logging event occurred
\&    %H Hostname (if Sys::Hostname is available)
\&    %l Fully qualified name of the calling method followed by the
\&       callers source the file name and line number between 
\&       parentheses.
\&    %L Line number within the file where the log statement was issued
\&    %m The message to be logged
\&    %m{chomp} Log message, stripped off a trailing newline
\&    %m{indent} Log message, multi\-lines indented so they line up with first
\&    %m{indent=n} Log message, multi\-lines indented by n spaces
\&    %M Method or function where the logging request was issued
\&    %n Newline (OS\-independent)
\&    %p Priority of the logging event (%p{1} shows the first letter)
\&    %P pid of the current process
\&    %r Number of milliseconds elapsed from program start to logging 
\&       event
\&    %R Number of milliseconds elapsed from last logging event to
\&       current logging event 
\&    %T A stack trace of functions called
\&    %x The topmost NDC (see below)
\&    %X{key} The entry \*(Aqkey\*(Aq of the MDC (see below)
\&    %% A literal percent (%) sign
.Ve
.PP
\&\s-1NDC\s0 and \s-1MDC\s0 are explained in \*(L"Nested Diagnostic Context (\s-1NDC\s0)\*(R" in Log::Log4perl
and \*(L"Mapped Diagnostic Context (\s-1MDC\s0)\*(R" in Log::Log4perl.
.PP
The granularity of time values is milliseconds if Time::HiRes is available.
If not, only full seconds are used.
.PP
Every once in a while, someone uses the \*(L"%m%n\*(R" pattern and
additionally provides an extra newline in the log message (e.g.
\&\f(CW\*(C`\->log("message\en")\*(C'\fR. To avoid printing an extra newline in
this case, the PatternLayout will chomp the message, printing only
one newline. This option can be controlled by PatternLayout's
\&\f(CW\*(C`message_chomp_before_newline\*(C'\fR option. See \*(L"Advanced options\*(R"
for details.
.SS "Quantify placeholders"
.IX Subsection "Quantify placeholders"
All placeholders can be extended with formatting instructions,
just like in \fIprintf\fR:
.PP
.Vb 7
\&    %20c   Reserve 20 chars for the category, right\-justify and fill
\&           with blanks if it is shorter
\&    %\-20c  Same as %20c, but left\-justify and fill the right side 
\&           with blanks
\&    %09r   Zero\-pad the number of milliseconds to 9 digits
\&    %.8c   Specify the maximum field with and have the formatter
\&           cut off the rest of the value
.Ve
.SS "Fine-tuning with curlies"
.IX Subsection "Fine-tuning with curlies"
Some placeholders have special functions defined if you add curlies 
with content after them:
.PP
.Vb 4
\&    %c{1}  Just show the right\-most category compontent, useful in large
\&           class hierarchies (Foo::Baz::Bar \-> Bar)
\&    %c{2}  Just show the two right most category components
\&           (Foo::Baz::Bar \-> Baz::Bar)
\&
\&    %F     Display source file including full path
\&    %F{1}  Just display filename
\&    %F{2}  Display filename and last path component (dir/test.log)
\&    %F{3}  Display filename and last two path components (d1/d2/test.log)
\&
\&    %M     Display fully qualified method/function name
\&    %M{1}  Just display method name (foo)
\&    %M{2}  Display method name and last path component (main::foo)
.Ve
.PP
In this way, you're able to shrink the displayed category or
limit file/path components to save space in your logs.
.SS "Fine-tune the date"
.IX Subsection "Fine-tune the date"
If you're not happy with the default \f(CW%d\fR format for the date which 
looks like
.PP
.Vb 1
\&    yyyy/MM/DD HH:mm:ss
.Ve
.PP
(which is slightly different from Log4j which uses \f(CW\*(C`yyyy\-MM\-dd HH:mm:ss,SSS\*(C'\fR)
you're free to fine-tune it in order to display only certain characteristics
of a date, according to the SimpleDateFormat in the Java World
(http://java.sun.com/j2se/1.3/docs/api/java/text/SimpleDateFormat.html):
.PP
.Vb 5
\&    %d{HH:mm}     "23:45" \-\- Just display hours and minutes
\&    %d{yy, EEEE}  "02, Monday" \-\- Just display two\-digit year 
\&                                  and spelled\-out weekday
\&Here\*(Aqs the symbols and their meaning, according to the SimpleDateFormat
\&specification:
\&
\&    Symbol   Meaning                 Presentation     Example
\&    \-\-\-\-\-\-   \-\-\-\-\-\-\-                 \-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-
\&    G        era designator          (Text)           AD
\&    y        year                    (Number)         1996 
\&    M        month in year           (Text & Number)  July & 07
\&    d        day in month            (Number)         10
\&    h        hour in am/pm (1\-12)    (Number)         12
\&    H        hour in day (0\-23)      (Number)         0
\&    m        minute in hour          (Number)         30
\&    s        second in minute        (Number)         55
\&    E        day in week             (Text)           Tuesday
\&    D        day in year             (Number)         189
\&    a        am/pm marker            (Text)           PM
\&    e        epoch seconds           (Number)         1315011604
\&
\&    (Text): 4 or more pattern letters\-\-use full form, < 4\-\-use short or 
\&            abbreviated form if one exists. 
\&
\&    (Number): the minimum number of digits. Shorter numbers are 
\&              zero\-padded to this amount. Year is handled 
\&              specially; that is, if the count of \*(Aqy\*(Aq is 2, the 
\&              Year will be truncated to 2 digits. 
\&
\&    (Text & Number): 3 or over, use text, otherwise use number.
.Ve
.PP
There's also a bunch of pre-defined formats:
.PP
.Vb 3
\&    %d{ABSOLUTE}   "HH:mm:ss,SSS"
\&    %d{DATE}       "dd MMM yyyy HH:mm:ss,SSS"
\&    %d{ISO8601}    "yyyy\-MM\-dd HH:mm:ss,SSS"
.Ve
.SS "Custom cspecs"
.IX Subsection "Custom cspecs"
First of all, \*(L"cspecs\*(R" is short for \*(L"conversion specifiers\*(R", which is 
the log4j and the \fIprintf\fR\|(3) term for what Mike is calling \*(L"placeholders.\*(R"
I suggested \*(L"cspecs\*(R" for this part of the api before I saw that Mike was 
using \*(L"placeholders\*(R" consistently in the log4perl documentation.  Ah, the
joys of collaboration ;=) \-\-kg
.PP
If the existing corpus of placeholders/cspecs isn't good enough for you,
you can easily roll your own:
.PP
.Vb 2
\&    #\*(AqU\*(Aq a global user\-defined cspec     
\&    log4j.PatternLayout.cspec.U = sub { return "UID: $< "}
\&    
\&    #\*(AqK\*(Aq cspec local to appndr1                 (pid in hex)
\&    log4j.appender.appndr1.layout.cspec.K = sub { return sprintf "%1x", $$}
\&    
\&    #and now you can use them
\&    log4j.appender.appndr1.layout.ConversionPattern = %K %U %m%n
.Ve
.PP
The benefit of this approach is that you can define and use the cspecs 
right next to each other in the config file.
.PP
If you're an \s-1API\s0 kind of person, there's also this call:
.PP
.Vb 2
\&    Log::Log4perl::Layout::PatternLayout::
\&                    add_global_cspec(\*(AqZ\*(Aq, sub {\*(Aqzzzzzzzz\*(Aq}); #snooze?
.Ve
.PP
When the log message is being put together, your anonymous sub 
will be called with these arguments:
.PP
.Vb 1
\&    ($layout, $message, $category, $priority, $caller_level);
\&    
\&    layout: the PatternLayout object that called it
\&    message: the logging message (%m)
\&    category: e.g. groceries.beverages.adult.beer.schlitz
\&    priority: e.g. DEBUG|WARN|INFO|ERROR|FATAL
\&    caller_level: how many levels back up the call stack you have 
\&        to go to find the caller
.Ve
.PP
Please note that the subroutines you're defining in this way are going
to be run in the \f(CW\*(C`main\*(C'\fR namespace, so be sure to fully qualify functions
and variables if they're located in different packages. \fIAlso make sure
these subroutines aren't using Log4perl, otherwise Log4perl will enter 
an infinite recursion.\fR
.PP
With Log4perl 1.20 and better, cspecs can be written with parameters in
curly braces. Writing something like
.PP
.Vb 1
\&    log4perl.appender.Screen.layout.ConversionPattern = %U{user} %U{id} %m%n
.Ve
.PP
will cause the cspec function defined for \f(CW%U\fR to be called twice, once
with the parameter 'user' and then again with the parameter 'id', 
and the placeholders in the cspec string will be replaced with
the respective return values.
.PP
The parameter value is available in the 'curlies' entry of the first
parameter passed to the subroutine (the layout object reference). 
So, if you wanted to map \f(CW%U\fR{xxx} to entries in the \s-1POE\s0 session hash, 
you'd write something like:
.PP
.Vb 2
\&   log4perl.PatternLayout.cspec.U = sub { \e
\&     POE::Kernel\->get_active_session\->get_heap()\->{ $_[0]\->{curlies} } }
.Ve
.PP
\&\fB\s-1SECURITY NOTE\s0\fR
.PP
This feature means arbitrary perl code can be embedded in the config file. 
In the rare case where the people who have access to your config file are
different from the people who write your code and shouldn't have execute
rights, you might want to set
.PP
.Vb 1
\&    $Log::Log4perl::Config\->allow_code(0);
.Ve
.PP
before you call \fIinit()\fR.  Alternatively you can supply a restricted set of
Perl opcodes that can be embedded in the config file as described in
\&\*(L"Restricting what Opcodes can be in a Perl Hook\*(R" in Log::Log4perl.
.SS "Advanced Options"
.IX Subsection "Advanced Options"
The constructor of the \f(CW\*(C`Log::Log4perl::Layout::PatternLayout\*(C'\fR class
takes an optional hash reference as a first argument to specify
additional options in order to (ab)use it in creative ways:
.PP
.Vb 4
\&  my $layout = Log::Log4perl::Layout::PatternLayout\->new(
\&    { time_function       => \e&my_time_func,
\&    }, 
\&    "%d (%F:%L)> %m");
.Ve
.PP
Here's a list of parameters:
.IP "time_function" 4
.IX Item "time_function"
Takes a reference to a function returning the time for the time/date
fields, either in seconds
since the epoch or as an array, carrying seconds and 
microseconds, just like \f(CW\*(C`Time::HiRes::gettimeofday\*(C'\fR does.
.IP "message_chomp_before_newline" 4
.IX Item "message_chomp_before_newline"
If a layout contains the pattern \*(L"%m%n\*(R" and the message ends with a newline,
PatternLayout will chomp the message, to prevent printing two newlines. 
If this is not desired, and you want two newlines in this case, 
the feature can be turned off by setting the
\&\f(CW\*(C`message_chomp_before_newline\*(C'\fR option to a false value:
.Sp
.Vb 4
\&  my $layout = Log::Log4perl::Layout::PatternLayout\->new(
\&      { message_chomp_before_newline => 0
\&      }, 
\&      "%d (%F:%L)> %m%n");
.Ve
.Sp
In a Log4perl configuration file, the feature can be turned off like this:
.Sp
.Vb 4
\&    log4perl.appender.App.layout   = PatternLayout
\&    log4perl.appender.App.layout.ConversionPattern = %d %m%n
\&      # Yes, I want two newlines
\&    log4perl.appender.App.layout.message_chomp_before_newline = 0
.Ve
.SS "Getting rid of newlines"
.IX Subsection "Getting rid of newlines"
If your code contains logging statements like
.PP
.Vb 2
\&      # WRONG, don\*(Aqt do that!
\&    $logger\->debug("Some message\en");
.Ve
.PP
then it's usually best to strip the newlines from these calls. As explained
in \*(L"Logging newlines\*(R" in Log::Log4perl, logging statements should never contain
newlines, but rely on appender layouts to add necessary newlines instead.
.PP
If changing the code is not an option, use the special PatternLayout 
placeholder \f(CW%m\fR{chomp} to refer to the message excluding a trailing 
newline:
.PP
.Vb 1
\&    log4perl.appender.App.layout.ConversionPattern = %d %m{chomp}%n
.Ve
.PP
This will add a single newline to every message, regardless if it
complies with the Log4perl newline guidelines or not (thanks to 
Tim Bunce for this idea).
.SS "Multi Lines"
.IX Subsection "Multi Lines"
If a log message consists of several lines, like
.PP
.Vb 1
\&    $logger\->debug("line1\enline2\enline3");
.Ve
.PP
then by default, they get logged like this (assuming the the layout is
set to \*(L"%d>%m%n\*(R"):
.PP
.Vb 4
\&      # layout %d>%m%n
\&    2014/07/27 12:46:16>line1
\&    line2
\&    line3
.Ve
.PP
If you'd rather have the messages aligned like
.PP
.Vb 4
\&      # layout %d>%m{indent}%n
\&    2014/07/27 12:46:16>line1
\&                        line2
\&                        line3
.Ve
.PP
then use the \f(CW%m{indent}\fR option for the \f(CW%m\fR specifier. This option
can also take a fixed value, as in \f(CW%m{indent=2}\fR, which indents
subsequent lines by two spaces:
.PP
.Vb 4
\&      # layout %d>%m{indent=2}%n
\&    2014/07/27 12:46:16>line1
\&      line2
\&      line3
.Ve
.PP
Note that you can still add the \f(CW\*(C`chomp\*(C'\fR option for the \f(CW%m\fR specifier
in this case (see above what it does), simply add it after a 
separating comma, like in \f(CW%m{indent=2,chomp}\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 2002\-2013 by Mike Schilli <m@perlmeister.com> 
and Kevin Goess <cpan@goess.org>.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please contribute patches to the project on Github:
.PP
.Vb 1
\&    http://github.com/mschilli/log4perl
.Ve
.PP
Send bug reports or requests for enhancements to the authors via our
.PP
\&\s-1MAILING LIST \s0(questions, bug reports, suggestions/patches): 
log4perl\-devel@lists.sourceforge.net
.PP
Authors (please contact them via the list above, not directly):
Mike Schilli <m@perlmeister.com>,
Kevin Goess <cpan@goess.org>
.PP
Contributors (in alphabetical order):
Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
Lars Thegler, David Viner, Mac Yang.
