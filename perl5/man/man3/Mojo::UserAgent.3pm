.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.30)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::UserAgent 3"
.TH Mojo::UserAgent 3 "2015-03-23" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::UserAgent \- Non\-blocking I/O HTTP and WebSocket user agent
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::UserAgent;
\&
\&  # Say hello to the Unicode snowman and include an Accept header
\&  my $ua = Mojo::UserAgent\->new;
\&  say $ua\->get(\*(Aqwww.â˜ƒ.net?hello=there\*(Aq => {Accept => \*(Aq*/*\*(Aq})\->res\->body;
\&
\&  # Form POST (application/x\-www\-form\-urlencoded) with exception handling
\&  my $tx = $ua\->post(\*(Aqhttps://metacpan.org/search\*(Aq => form => {q => \*(Aqmojo\*(Aq});
\&  if (my $res = $tx\->success) { say $res\->body }
\&  else {
\&    my $err = $tx\->error;
\&    die "$err\->{code} response: $err\->{message}" if $err\->{code};
\&    die "Connection error: $err\->{message}";
\&  }
\&
\&  # Extract data from HTML and XML resources with CSS selectors
\&  say $ua\->get(\*(Aqwww.perl.org\*(Aq)\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&
\&  # Scrape the latest headlines from a news site
\&  say $ua\->get(\*(Aqblogs.perl.org\*(Aq)
\&    \->res\->dom\->find(\*(Aqh2 > a\*(Aq)\->map(\*(Aqtext\*(Aq)\->join("\en");
\&
\&  # IPv6 PUT request with Content\-Type header and content
\&  my $tx = $ua\->put(\*(Aq[::1]:3000\*(Aq => {\*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq} => \*(AqHi!\*(Aq);
\&
\&  # Quick JSON API request with Basic authentication
\&  my $value = $ua\->get(\*(Aqhttps://sri:s3cret@example.com/test.json\*(Aq)\->res\->json;
\&
\&  # JSON POST (application/json) with TLS certificate authentication
\&  my $tx = $ua\->cert(\*(Aqtls.crt\*(Aq)\->key(\*(Aqtls.key\*(Aq)
\&    \->post(\*(Aqhttps://example.com\*(Aq => json => {top => \*(Aqsecret\*(Aq});
\&
\&  # Search DuckDuckGo anonymously through Tor
\&  $ua\->proxy\->http(\*(Aqsocks://127.0.0.1:9050\*(Aq);
\&  say $ua\->get(\*(Aqapi.3g2upl4pq6kufc4m.onion/?q=mojolicious&format=json\*(Aq)
\&    \->res\->json(\*(Aq/Abstract\*(Aq);
\&
\&  # Follow redirects to download Mojolicious from GitHub
\&  $ua\->max_redirects(5)
\&    \->get(\*(Aqhttps://www.github.com/kraih/mojo/tarball/master\*(Aq)
\&    \->res\->content\->asset\->move_to(\*(Aq/home/sri/mojo.tar.gz\*(Aq);
\&
\&  # Non\-blocking concurrent requests
\&  Mojo::IOLoop\->delay(
\&    sub {
\&      my $delay = shift;
\&      $ua\->get(\*(Aqmojolicio.us\*(Aq => $delay\->begin);
\&      $ua\->get(\*(Aqcpan.org\*(Aq     => $delay\->begin);
\&    },
\&    sub {
\&      my ($delay, $mojo, $cpan) = @_;
\&      say $mojo\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&      say $cpan\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text;
\&    }
\&  )\->wait;
\&
\&  # Non\-blocking WebSocket connection sending and receiving JSON messages
\&  $ua\->websocket(\*(Aqws://example.com/echo.json\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say \*(AqWebSocket handshake failed!\*(Aq and return unless $tx\->is_websocket;
\&    $tx\->on(json => sub {
\&      my ($tx, $hash) = @_;
\&      say "WebSocket message via JSON: $hash\->{msg}";
\&      $tx\->finish;
\&    });
\&    $tx\->send({json => {msg => \*(AqHello World!\*(Aq}});
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::UserAgent is a full featured non-blocking I/O \s-1HTTP\s0 and WebSocket user
agent, with IPv6, \s-1TLS, SNI, IDNA, HTTP/SOCKS5\s0 proxy, Comet (long polling),
keep-alive, connection pooling, timeout, cookie, multipart, gzip compression
and multiple event loop support.
.PP
All connections will be reset automatically if a new process has been forked,
this allows multiple processes to share the same Mojo::UserAgent object
safely.
.PP
For better scalability (epoll, kqueue) and to provide non-blocking name
resolution, \s-1SOCKS5\s0 as well as \s-1TLS\s0 support, the optional modules \s-1EV\s0 (4.0+),
Net::DNS::Native (0.15+), IO::Socket::Socks (0.64+) and
IO::Socket::SSL (1.94+) will be used automatically if possible. Individual
features can also be disabled with the \f(CW\*(C`MOJO_NO_NDN\*(C'\fR, \f(CW\*(C`MOJO_NO_SOCKS\*(C'\fR and
\&\f(CW\*(C`MOJO_NO_TLS\*(C'\fR environment variables.
.PP
See \*(L"\s-1USER AGENT\*(R"\s0 in Mojolicious::Guides::Cookbook for more.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::UserAgent inherits all events from Mojo::EventEmitter and can emit
the following new ones.
.SS "start"
.IX Subsection "start"
.Vb 4
\&  $ua\->on(start => sub {
\&    my ($ua, $tx) = @_;
\&    ...
\&  });
.Ve
.PP
Emitted whenever a new transaction is about to start, this includes
automatically prepared proxy \f(CW\*(C`CONNECT\*(C'\fR requests and followed redirects.
.PP
.Vb 4
\&  $ua\->on(start => sub {
\&    my ($ua, $tx) = @_;
\&    $tx\->req\->headers\->header(\*(AqX\-Bender\*(Aq => \*(AqBite my shiny metal ass!\*(Aq);
\&  });
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::UserAgent implements the following attributes.
.SS "ca"
.IX Subsection "ca"
.Vb 2
\&  my $ca = $ua\->ca;
\&  $ua    = $ua\->ca(\*(Aq/etc/tls/ca.crt\*(Aq);
.Ve
.PP
Path to \s-1TLS\s0 certificate authority file, defaults to the value of the
\&\f(CW\*(C`MOJO_CA_FILE\*(C'\fR environment variable. Also activates hostname verification.
.PP
.Vb 3
\&  # Show certificate authorities for debugging
\&  IO::Socket::SSL::set_defaults(
\&    SSL_verify_callback => sub { say "Authority: $_[2]" and return $_[0] });
.Ve
.SS "cert"
.IX Subsection "cert"
.Vb 2
\&  my $cert = $ua\->cert;
\&  $ua      = $ua\->cert(\*(Aq/etc/tls/client.crt\*(Aq);
.Ve
.PP
Path to \s-1TLS\s0 certificate file, defaults to the value of the \f(CW\*(C`MOJO_CERT_FILE\*(C'\fR
environment variable.
.SS "connect_timeout"
.IX Subsection "connect_timeout"
.Vb 2
\&  my $timeout = $ua\->connect_timeout;
\&  $ua         = $ua\->connect_timeout(5);
.Ve
.PP
Maximum amount of time in seconds establishing a connection may take before
getting canceled, defaults to the value of the \f(CW\*(C`MOJO_CONNECT_TIMEOUT\*(C'\fR
environment variable or \f(CW10\fR.
.SS "cookie_jar"
.IX Subsection "cookie_jar"
.Vb 2
\&  my $cookie_jar = $ua\->cookie_jar;
\&  $ua            = $ua\->cookie_jar(Mojo::UserAgent::CookieJar\->new);
.Ve
.PP
Cookie jar to use for requests performed by this user agent, defaults to a
Mojo::UserAgent::CookieJar object.
.PP
.Vb 2
\&  # Disable collecting cookies from responses
\&  $ua\->cookie_jar\->collecting(0);
\&
\&  # Add custom cookie to the jar
\&  $ua\->cookie_jar\->add(
\&    Mojo::Cookie::Response\->new(
\&      name   => \*(Aqfoo\*(Aq,
\&      value  => \*(Aqbar\*(Aq,
\&      domain => \*(Aqmojolicio.us\*(Aq,
\&      path   => \*(Aq/perldoc\*(Aq
\&    )
\&  );
.Ve
.SS "inactivity_timeout"
.IX Subsection "inactivity_timeout"
.Vb 2
\&  my $timeout = $ua\->inactivity_timeout;
\&  $ua         = $ua\->inactivity_timeout(15);
.Ve
.PP
Maximum amount of time in seconds a connection can be inactive before getting
closed, defaults to the value of the \f(CW\*(C`MOJO_INACTIVITY_TIMEOUT\*(C'\fR environment
variable or \f(CW20\fR. Setting the value to \f(CW0\fR will allow connections to be
inactive indefinitely.
.SS "ioloop"
.IX Subsection "ioloop"
.Vb 2
\&  my $loop = $ua\->ioloop;
\&  $ua      = $ua\->ioloop(Mojo::IOLoop\->new);
.Ve
.PP
Event loop object to use for blocking I/O operations, defaults to a
Mojo::IOLoop object.
.SS "key"
.IX Subsection "key"
.Vb 2
\&  my $key = $ua\->key;
\&  $ua     = $ua\->key(\*(Aq/etc/tls/client.crt\*(Aq);
.Ve
.PP
Path to \s-1TLS\s0 key file, defaults to the value of the \f(CW\*(C`MOJO_KEY_FILE\*(C'\fR environment
variable.
.SS "local_address"
.IX Subsection "local_address"
.Vb 2
\&  my $address = $ua\->local_address;
\&  $ua         = $ua\->local_address(\*(Aq127.0.0.1\*(Aq);
.Ve
.PP
Local address to bind to.
.SS "max_connections"
.IX Subsection "max_connections"
.Vb 2
\&  my $max = $ua\->max_connections;
\&  $ua     = $ua\->max_connections(5);
.Ve
.PP
Maximum number of keep-alive connections that the user agent will retain before
it starts closing the oldest ones, defaults to \f(CW5\fR. Setting the value to \f(CW0\fR
will prevent any connections from being kept alive.
.SS "max_redirects"
.IX Subsection "max_redirects"
.Vb 2
\&  my $max = $ua\->max_redirects;
\&  $ua     = $ua\->max_redirects(3);
.Ve
.PP
Maximum number of redirects the user agent will follow before it fails,
defaults to the value of the \f(CW\*(C`MOJO_MAX_REDIRECTS\*(C'\fR environment variable or
\&\f(CW0\fR.
.SS "proxy"
.IX Subsection "proxy"
.Vb 2
\&  my $proxy = $ua\->proxy;
\&  $ua       = $ua\->proxy(Mojo::UserAgent::Proxy\->new);
.Ve
.PP
Proxy manager, defaults to a Mojo::UserAgent::Proxy object.
.PP
.Vb 2
\&  # Detect proxy servers from environment
\&  $ua\->proxy\->detect;
\&
\&  # Manually configure HTTP proxy (using CONNECT for HTTPS)
\&  $ua\->proxy\->http(\*(Aqhttp://127.0.0.1:8080\*(Aq)\->https(\*(Aqhttp://127.0.0.1:8080\*(Aq);
\&
\&  # Manually configure Tor (SOCKS5)
\&  $ua\->proxy\->http(\*(Aqsocks://127.0.0.1:9050\*(Aq)\->https(\*(Aqsocks://127.0.0.1:9050\*(Aq);
.Ve
.SS "request_timeout"
.IX Subsection "request_timeout"
.Vb 2
\&  my $timeout = $ua\->request_timeout;
\&  $ua         = $ua\->request_timeout(5);
.Ve
.PP
Maximum amount of time in seconds establishing a connection, sending the
request and receiving a whole response may take before getting canceled,
defaults to the value of the \f(CW\*(C`MOJO_REQUEST_TIMEOUT\*(C'\fR environment variable or
\&\f(CW0\fR. Setting the value to \f(CW0\fR will allow the user agent to wait indefinitely.
The timeout will reset for every followed redirect.
.PP
.Vb 2
\&  # Total limit of 5 seconds, of which 3 seconds may be spent connecting
\&  $ua\->max_redirects(0)\->connect_timeout(3)\->request_timeout(5);
.Ve
.SS "server"
.IX Subsection "server"
.Vb 2
\&  my $server = $ua\->server;
\&  $ua        = $ua\->server(Mojo::UserAgent::Server\->new);
.Ve
.PP
Application server relative URLs will be processed with, defaults to a
Mojo::UserAgent::Server object.
.PP
.Vb 2
\&  # Introspect
\&  say for @{$ua\->server\->app\->secrets};
\&
\&  # Change log level
\&  $ua\->server\->app\->log\->level(\*(Aqfatal\*(Aq);
\&
\&  # Port currently used for processing relative URLs blocking
\&  say $ua\->server\->url\->port;
\&
\&  # Port currently used for processing relative URLs non\-blocking
\&  say $ua\->server\->nb_url\->port;
.Ve
.SS "transactor"
.IX Subsection "transactor"
.Vb 2
\&  my $t = $ua\->transactor;
\&  $ua   = $ua\->transactor(Mojo::UserAgent::Transactor\->new);
.Ve
.PP
Transaction builder, defaults to a Mojo::UserAgent::Transactor object.
.PP
.Vb 2
\&  # Change name of user agent
\&  $ua\->transactor\->name(\*(AqMyUA 1.0\*(Aq);
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojo::UserAgent inherits all methods from Mojo::EventEmitter and
implements the following new ones.
.SS "build_tx"
.IX Subsection "build_tx"
.Vb 7
\&  my $tx = $ua\->build_tx(GET => \*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->build_tx(
\&    PUT => \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->build_tx(
\&    PUT => \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->build_tx(
\&    PUT => \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Generate Mojo::Transaction::HTTP object with
\&\*(L"tx\*(R" in Mojo::UserAgent::Transactor.
.PP
.Vb 4
\&  # Request with custom cookie
\&  my $tx = $ua\->build_tx(GET => \*(Aqhttps://example.com/account\*(Aq);
\&  $tx\->req\->cookies({name => \*(Aquser\*(Aq, value => \*(Aqsri\*(Aq});
\&  $tx = $ua\->start($tx);
\&
\&  # Deactivate gzip compression
\&  my $tx = $ua\->build_tx(GET => \*(Aqexample.com\*(Aq);
\&  $tx\->req\->headers\->remove(\*(AqAccept\-Encoding\*(Aq);
\&  $tx = $ua\->start($tx);
\&
\&  # Interrupt response by raising an error
\&  my $tx = $ua\->build_tx(GET => \*(Aqhttp://example.com\*(Aq);
\&  $tx\->res\->on(progress => sub {
\&    my $res = shift;
\&    return unless my $server = $res\->headers\->server;
\&    $res\->error({message => \*(AqOh noes, it is IIS!\*(Aq}) if $server =~ /IIS/;
\&  });
\&  $tx = $ua\->start($tx);
.Ve
.SS "build_websocket_tx"
.IX Subsection "build_websocket_tx"
.Vb 3
\&  my $tx = $ua\->build_websocket_tx(\*(Aqws://example.com\*(Aq);
\&  my $tx = $ua\->build_websocket_tx(
\&    \*(Aqws://example.com\*(Aq => {DNT => 1} => [\*(Aqv1.proto\*(Aq]);
.Ve
.PP
Generate Mojo::Transaction::HTTP object with
\&\*(L"websocket\*(R" in Mojo::UserAgent::Transactor.
.PP
.Vb 10
\&  # Custom WebSocket handshake with cookie
\&  my $tx = $ua\->build_websocket_tx(\*(Aqwss://example.com/echo\*(Aq);
\&  $tx\->req\->cookies({name => \*(Aquser\*(Aq, value => \*(Aqsri\*(Aq});
\&  $ua\->start($tx => sub {
\&    my ($ua, $tx) = @_;
\&    say \*(AqWebSocket handshake failed!\*(Aq and return unless $tx\->is_websocket;
\&    $tx\->on(message => sub {
\&      my ($tx, $msg) = @_;
\&      say "WebSocket message: $msg";
\&      $tx\->finish;
\&    });
\&    $tx\->send(\*(AqHi!\*(Aq);
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "delete"
.IX Subsection "delete"
.Vb 6
\&  my $tx = $ua\->delete(\*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->delete(\*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->delete(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->delete(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Perform blocking \f(CW\*(C`DELETE\*(C'\fR request and return resulting
Mojo::Transaction::HTTP object, takes the same arguments as
\&\*(L"tx\*(R" in Mojo::UserAgent::Transactor (except for the \f(CW\*(C`DELETE\*(C'\fR method, which is
implied). You can also append a callback to perform requests non-blocking.
.PP
.Vb 5
\&  $ua\->delete(\*(Aqhttp://example.com\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "get"
.IX Subsection "get"
.Vb 6
\&  my $tx = $ua\->get(\*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->get(\*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->get(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->get(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Perform blocking \f(CW\*(C`GET\*(C'\fR request and return resulting Mojo::Transaction::HTTP
object, takes the same arguments as \*(L"tx\*(R" in Mojo::UserAgent::Transactor (except
for the \f(CW\*(C`GET\*(C'\fR method, which is implied). You can also append a callback to
perform requests non-blocking.
.PP
.Vb 5
\&  $ua\->get(\*(Aqhttp://example.com\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "head"
.IX Subsection "head"
.Vb 6
\&  my $tx = $ua\->head(\*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->head(\*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->head(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->head(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Perform blocking \f(CW\*(C`HEAD\*(C'\fR request and return resulting
Mojo::Transaction::HTTP object, takes the same arguments as
\&\*(L"tx\*(R" in Mojo::UserAgent::Transactor (except for the \f(CW\*(C`HEAD\*(C'\fR method, which is
implied). You can also append a callback to perform requests non-blocking.
.PP
.Vb 5
\&  $ua\->head(\*(Aqhttp://example.com\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "options"
.IX Subsection "options"
.Vb 6
\&  my $tx = $ua\->options(\*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->options(\*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->options(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->options(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Perform blocking \f(CW\*(C`OPTIONS\*(C'\fR request and return resulting
Mojo::Transaction::HTTP object, takes the same arguments as
\&\*(L"tx\*(R" in Mojo::UserAgent::Transactor (except for the \f(CW\*(C`OPTIONS\*(C'\fR method, which is
implied). You can also append a callback to perform requests non-blocking.
.PP
.Vb 5
\&  $ua\->options(\*(Aqhttp://example.com\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "patch"
.IX Subsection "patch"
.Vb 6
\&  my $tx = $ua\->patch(\*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->patch(\*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->patch(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->patch(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Perform blocking \f(CW\*(C`PATCH\*(C'\fR request and return resulting
Mojo::Transaction::HTTP object, takes the same arguments as
\&\*(L"tx\*(R" in Mojo::UserAgent::Transactor (except for the \f(CW\*(C`PATCH\*(C'\fR method, which is
implied). You can also append a callback to perform requests non-blocking.
.PP
.Vb 5
\&  $ua\->patch(\*(Aqhttp://example.com\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "post"
.IX Subsection "post"
.Vb 6
\&  my $tx = $ua\->post(\*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->post(\*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->post(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->post(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Perform blocking \f(CW\*(C`POST\*(C'\fR request and return resulting
Mojo::Transaction::HTTP object, takes the same arguments as
\&\*(L"tx\*(R" in Mojo::UserAgent::Transactor (except for the \f(CW\*(C`POST\*(C'\fR method, which is
implied). You can also append a callback to perform requests non-blocking.
.PP
.Vb 5
\&  $ua\->post(\*(Aqhttp://example.com\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "put"
.IX Subsection "put"
.Vb 6
\&  my $tx = $ua\->put(\*(Aqexample.com\*(Aq);
\&  my $tx = $ua\->put(\*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => \*(AqHi!\*(Aq);
\&  my $tx = $ua\->put(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => form => {a => \*(Aqb\*(Aq});
\&  my $tx = $ua\->put(
\&    \*(Aqhttp://example.com\*(Aq => {Accept => \*(Aq*/*\*(Aq} => json => {a => \*(Aqb\*(Aq});
.Ve
.PP
Perform blocking \f(CW\*(C`PUT\*(C'\fR request and return resulting Mojo::Transaction::HTTP
object, takes the same arguments as \*(L"tx\*(R" in Mojo::UserAgent::Transactor (except
for the \f(CW\*(C`PUT\*(C'\fR method, which is implied). You can also append a callback to
perform requests non-blocking.
.PP
.Vb 5
\&  $ua\->put(\*(Aqhttp://example.com\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "start"
.IX Subsection "start"
.Vb 1
\&  my $tx = $ua\->start(Mojo::Transaction::HTTP\->new);
.Ve
.PP
Perform blocking request for a custom Mojo::Transaction::HTTP object, which
can be prepared manually or with \*(L"build_tx\*(R". You can also append a callback
to perform requests non-blocking.
.PP
.Vb 6
\&  my $tx = $ua\->build_tx(GET => \*(Aqhttp://example.com\*(Aq);
\&  $ua\->start($tx => sub {
\&    my ($ua, $tx) = @_;
\&    say $tx\->res\->body;
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "websocket"
.IX Subsection "websocket"
.Vb 3
\&  $ua\->websocket(\*(Aqws://example.com\*(Aq => sub {...});
\&  $ua\->websocket(
\&    \*(Aqws://example.com\*(Aq => {DNT => 1} => [\*(Aqv1.proto\*(Aq] => sub {...});
.Ve
.PP
Open a non-blocking WebSocket connection with transparent handshake, takes the
same arguments as \*(L"websocket\*(R" in Mojo::UserAgent::Transactor. The callback will
receive either a Mojo::Transaction::WebSocket or Mojo::Transaction::HTTP
object, depending on if the handshake was successful.
.PP
.Vb 10
\&  $ua\->websocket(\*(Aqwss://example.com/echo\*(Aq => sub {
\&    my ($ua, $tx) = @_;
\&    say \*(AqWebSocket handshake failed!\*(Aq and return unless $tx\->is_websocket;
\&    $tx\->on(finish => sub {
\&      my ($tx, $code, $reason) = @_;
\&      say "WebSocket closed with status $code.";
\&    });
\&    $tx\->on(message => sub {
\&      my ($tx, $msg) = @_;
\&      say "WebSocket message: $msg";
\&      $tx\->finish;
\&    });
\&    $tx\->send(\*(AqHi!\*(Aq);
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.PP
You can activate \f(CW\*(C`permessage\-deflate\*(C'\fR compression by setting the
\&\f(CW\*(C`Sec\-WebSocket\-Extensions\*(C'\fR header, this can result in much better performance,
but also increases memory usage by up to 300KB per connection.
.PP
.Vb 2
\&  my $headers = {\*(AqSec\-WebSocket\-Extensions\*(Aq => \*(Aqpermessage\-deflate\*(Aq};
\&  $ua\->websocket(\*(Aqws://example.com/foo\*(Aq => $headers => sub {...});
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`MOJO_USERAGENT_DEBUG\*(C'\fR environment variable to get some
advanced diagnostics information printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_USERAGENT_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
