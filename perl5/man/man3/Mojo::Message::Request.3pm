.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Message::Request 3"
.TH Mojo::Message::Request 3 "2014-08-07" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Message::Request \- HTTP request
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Message::Request;
\&
\&  # Parse
\&  my $req = Mojo::Message::Request\->new;
\&  $req\->parse("GET /foo HTTP/1.0\ex0d\ex0a");
\&  $req\->parse("Content\-Length: 12\ex0d\ex0a");
\&  $req\->parse("Content\-Type: text/plain\ex0d\ex0a\ex0d\ex0a");
\&  $req\->parse(\*(AqHello World!\*(Aq);
\&  say $req\->method;
\&  say $req\->headers\->content_type;
\&  say $req\->body;
\&
\&  # Build
\&  my $req = Mojo::Message::Request\->new;
\&  $req\->url\->parse(\*(Aqhttp://127.0.0.1/foo/bar\*(Aq);
\&  $req\->method(\*(AqGET\*(Aq);
\&  say $req\->to_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Message::Request is a container for \s-1HTTP\s0 requests based on
<\s-1RFC\s0 7230>,
<\s-1RFC\s0 7231>,
<\s-1RFC\s0 7231> and
<\s-1RFC\s0 2817>.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::Message::Request inherits all events from Mojo::Message.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::Message::Request inherits all attributes from Mojo::Message and
implements the following new ones.
.SS "env"
.IX Subsection "env"
.Vb 2
\&  my $env = $req\->env;
\&  $req    = $req\->env({});
.Ve
.PP
Direct access to the \f(CW\*(C`CGI\*(C'\fR or \f(CW\*(C`PSGI\*(C'\fR environment hash if available.
.PP
.Vb 2
\&  # Check CGI version
\&  my $version = $req\->env\->{GATEWAY_INTERFACE};
\&
\&  # Check PSGI version
\&  my $version = $req\->env\->{\*(Aqpsgi.version\*(Aq};
.Ve
.SS "method"
.IX Subsection "method"
.Vb 2
\&  my $method = $req\->method;
\&  $req       = $req\->method(\*(AqPOST\*(Aq);
.Ve
.PP
\&\s-1HTTP\s0 request method, defaults to \f(CW\*(C`GET\*(C'\fR.
.SS "url"
.IX Subsection "url"
.Vb 2
\&  my $url = $req\->url;
\&  $req    = $req\->url(Mojo::URL\->new);
.Ve
.PP
\&\s-1HTTP\s0 request \s-1URL\s0, defaults to a Mojo::URL object.
.PP
.Vb 4
\&  # Get request information
\&  say $req\->url\->to_abs\->userinfo;
\&  say $req\->url\->to_abs\->host;
\&  say $req\->url\->to_abs\->path;
.Ve
.SS "reverse_proxy"
.IX Subsection "reverse_proxy"
.Vb 2
\&  my $bool = $req\->reverse_proxy;
\&  $req     = $req\->reverse_proxy($bool);
.Ve
.PP
Request has been performed through a reverse proxy.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Message::Request inherits all methods from Mojo::Message and
implements the following new ones.
.SS "clone"
.IX Subsection "clone"
.Vb 1
\&  my $clone = $req\->clone;
.Ve
.PP
Clone request if possible, otherwise return \f(CW\*(C`undef\*(C'\fR.
.SS "cookies"
.IX Subsection "cookies"
.Vb 3
\&  my $cookies = $req\->cookies;
\&  $req        = $req\->cookies(Mojo::Cookie::Request\->new);
\&  $req        = $req\->cookies({name => \*(Aqfoo\*(Aq, value => \*(Aqbar\*(Aq});
.Ve
.PP
Access request cookies, usually Mojo::Cookie::Request objects.
.SS "extract_start_line"
.IX Subsection "extract_start_line"
.Vb 1
\&  my $bool = $req\->extract_start_line(\e$str);
.Ve
.PP
Extract request line from string.
.SS "fix_headers"
.IX Subsection "fix_headers"
.Vb 1
\&  $req = $req\->fix_headers;
.Ve
.PP
Make sure request has all required headers.
.SS "get_start_line_chunk"
.IX Subsection "get_start_line_chunk"
.Vb 1
\&  my $bytes = $req\->get_start_line_chunk($offset);
.Ve
.PP
Get a chunk of request line data starting from a specific position.
.SS "is_handshake"
.IX Subsection "is_handshake"
.Vb 1
\&  my $bool = $req\->is_handshake;
.Ve
.PP
Check \f(CW\*(C`Upgrade\*(C'\fR header for \f(CW\*(C`websocket\*(C'\fR value.
.SS "is_secure"
.IX Subsection "is_secure"
.Vb 1
\&  my $bool = $req\->is_secure;
.Ve
.PP
Check if connection is secure.
.SS "is_xhr"
.IX Subsection "is_xhr"
.Vb 1
\&  my $bool = $req\->is_xhr;
.Ve
.PP
Check \f(CW\*(C`X\-Requested\-With\*(C'\fR header for \f(CW\*(C`XMLHttpRequest\*(C'\fR value.
.SS "param"
.IX Subsection "param"
.Vb 4
\&  my @names       = $req\->param;
\&  my $foo         = $req\->param(\*(Aqfoo\*(Aq);
\&  my @foo         = $req\->param(\*(Aqfoo\*(Aq);
\&  my ($foo, $bar) = $req\->param([\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]);
.Ve
.PP
Access \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR parameters extracted from the query string and
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR or \f(CW\*(C`multipart/form\-data\*(C'\fR message body.
Note that this method caches all data, so it should not be called before the
entire request body has been received. Parts of the request body need to be
loaded into memory to parse \f(CW\*(C`POST\*(C'\fR parameters, so you have to make sure it is
not excessively large, there's a 10MB limit by default.
.SS "params"
.IX Subsection "params"
.Vb 1
\&  my $params = $req\->params;
.Ve
.PP
All \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR parameters extracted from the query string and
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR or \f(CW\*(C`multipart/form\-data\*(C'\fR message body,
usually a Mojo::Parameters object. Note that this method caches all data,
so it should not be called before the entire request body has been received.
Parts of the request body need to be loaded into memory to parse \f(CW\*(C`POST\*(C'\fR
parameters, so you have to make sure it is not excessively large, there's a
10MB limit by default.
.PP
.Vb 2
\&  # Get parameter value
\&  say $req\->params\->param(\*(Aqfoo\*(Aq);
.Ve
.SS "parse"
.IX Subsection "parse"
.Vb 3
\&  $req = $req\->parse(\*(AqGET /foo/bar HTTP/1.1\*(Aq);
\&  $req = $req\->parse(REQUEST_METHOD => \*(AqGET\*(Aq);
\&  $req = $req\->parse({REQUEST_METHOD => \*(AqGET\*(Aq});
.Ve
.PP
Parse \s-1HTTP\s0 request chunks or environment hash.
.SS "proxy"
.IX Subsection "proxy"
.Vb 3
\&  my $proxy = $req\->proxy;
\&  $req      = $req\->proxy(\*(Aqhttp://foo:bar@127.0.0.1:3000\*(Aq);
\&  $req      = $req\->proxy(Mojo::URL\->new(\*(Aqhttp://127.0.0.1:3000\*(Aq));
.Ve
.PP
Proxy \s-1URL\s0 for request.
.PP
.Vb 2
\&  # Disable proxy
\&  $req\->proxy(0);
.Ve
.SS "query_params"
.IX Subsection "query_params"
.Vb 1
\&  my $params = $req\->query_params;
.Ve
.PP
All \f(CW\*(C`GET\*(C'\fR parameters, usually a Mojo::Parameters object.
.PP
.Vb 2
\&  # Turn GET parameters to hash and extract value
\&  say $req\->query_params\->to_hash\->{foo};
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
