.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Statistics::LineFit 3"
.TH Statistics::LineFit 3 "2004-09-02" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Statistics::LineFit \- Least squares line fit, weighted or unweighted
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\& use Statistics::LineFit;
\& $lineFit = Statistics::LineFit\->new();
\& $lineFit\->setData (\e@xValues, \e@yValues) or die "Invalid data";
\& ($intercept, $slope) = $lineFit\->coefficients();
\& defined $intercept or die "Can\*(Aqt fit line if x values are all equal";
\& $rSquared = $lineFit\->rSquared();
\& $meanSquaredError = $lineFit\->meanSqError();
\& $durbinWatson = $lineFit\->durbinWatson();
\& $sigma = $lineFit\->sigma();
\& ($tStatIntercept, $tStatSlope) = $lineFit\->tStatistics();
\& @predictedYs = $lineFit\->predictedYs();
\& @residuals = $lineFit\->residuals();
\& (varianceIntercept, $varianceSlope) = $lineFit\->varianceOfEstimates();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Statistics::LineFit module does weighted or unweighted least-squares
line fitting to two-dimensional data (y = a + b * x).  (This is also called
linear regression.)  In addition to the slope and y\-intercept, the module
can return the square of the correlation coefficient (R squared), the
Durbin-Watson statistic, the mean squared error, sigma, the t statistics,
the variance of the estimates of the slope and y\-intercept, 
the predicted y values and the residuals of the y values.  (See the \s-1METHODS\s0
section for a description of these statistics.)
.PP
The module accepts input data in separate x and y arrays or a single
2\-D array (an array of arrayrefs).  The optional weights are input in a
separate array.  The module can optionally verify that the input data and
weights are valid numbers.  If weights are input, the line fit minimizes
the weighted sum of the squared errors and the following statistics are
weighted: the correlation coefficient, the Durbin-Watson statistic, the
mean squared error, sigma and the t statistics.
.PP
The module is state-oriented and caches its results.  Once you call the
\&\fIsetData()\fR method, you can call the other methods in any order or call a
method several times without invoking redundant calculations.  After calling
\&\fIsetData()\fR, you can modify the input data or weights without affecting the
module's results.
.PP
The decision to use or not use weighting could be made using your a
priori knowledge of the data or using supplemental data.  If the data is
sparse or contains non-random noise, weighting can degrade the solution.
Weighting is a good option if some points are suspect or less relevant (e.g.,
older terms in a time series, points that are known to have more noise).
.SH "ALGORITHM"
.IX Header "ALGORITHM"
The least-square line is the line that minimizes the sum of the squares
of the y residuals:
.PP
.Vb 1
\& Minimize SUM((y[i] \- (a + b * x[i])) ** 2)
.Ve
.PP
Setting the parial derivatives of a and b to zero yields a solution that
can be expressed in terms of the means, variances and covariances of x and y:
.PP
.Vb 1
\& b = SUM((x[i] \- meanX) * (y[i] \- meanY)) / SUM((x[i] \- meanX) ** 2) 
\&
\& a = meanY \- b * meanX
.Ve
.PP
Note that a and b are undefined if all the x values are the same.
.PP
If you use weights, each term in the above sums is multiplied by the
value of the weight for that index.  The program normalizes the weights
(after copying the input values) so that the sum of the weights equals
the number of points.  This minimizes the differences between the weighted
and unweighted equations.
.PP
Statistics::LineFit uses equations that are mathematically equivalent to
the above equations and computationally more efficient.  The module runs
in O(N) (linear time).
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
The regression fails if the input x values are all equal or the only unequal
x values have zero weights.  This is an inherent limit to fitting a line of
the form y = a + b * x.  In this case, the module issues an error message
and methods that return statistical values will return undefined values.
You can also use the return value of the \fIregress()\fR method to check the
status of the regression.
.PP
As the sum of the squared deviations of the x values approaches zero,
the module's results becomes sensitive to the precision of floating point
operations on the host system.
.PP
If the x values are not all the same and the apparent \*(L"best fit\*(R" line is
vertical, the module will fit a horizontal line.  For example, an input of
(1, 1), (1, 7), (2, 3), (2, 5) returns a slope of zero, an intercept of 4
and an R squared of zero.  This is correct behavior because this line is the
best least-squares fit to the data for the given parameterization 
(y = a + b * x).
.PP
On a 32\-bit system the results are accurate to about 11 significant digits,
depending on the input data.  Many of the installation tests will fail
on a system with word lengths of 16 bits or fewer.  (You might want to
upgrade your old 80286 \s-1IBM\s0 \s-1PC\s0.)
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Alternate calling sequence:"
.IX Subsection "Alternate calling sequence:"
.Vb 9
\& use Statistics::LineFit;
\& $lineFit = Statistics::LineFit\->new();
\& $lineFit\->setData(\e@x, \e@y) or die "Invalid regression data\en";
\& if (defined $lineFit\->rSquared()
\&     and $lineFit\->rSquared() > $threshold) 
\& {
\&     ($intercept, $slope) = $lineFit\->coefficients();
\&     print "Slope: $slope  Y\-intercept: $intercept\en";
\& }
.Ve
.SS "Multiple calls with same object, validate input, suppress error messages:"
.IX Subsection "Multiple calls with same object, validate input, suppress error messages:"
.Vb 10
\& use Statistics::LineFit;
\& $lineFit = Statistics::LineFit\->new(1, 1);
\& while (1) {
\&     @xy = read2Dxy();  # User\-supplied subroutine
\&     $lineFit\->setData(\e@xy);
\&     ($intercept, $slope) = $lineFit\->coefficients();
\&     if (defined $intercept) {
\&         print "Slope: $slope  Y\-intercept: $intercept\en";
\&     } 
\& }
.Ve
.SH "METHODS"
.IX Header "METHODS"
The module is state-oriented and caches its results.  Once you call the
\&\fIsetData()\fR method, you can call the other methods in any order or call
a method several times without invoking redundant calculations.
.PP
The regression fails if the x values are all the same.  In this case,
the module issues an error message and methods that return statistical
values will return undefined values.  You can also use the return value 
of the \fIregress()\fR method to check the status of the regression.
.SS "\fInew()\fP \- create a new Statistics::LineFit object"
.IX Subsection "new() - create a new Statistics::LineFit object"
.Vb 3
\& $lineFit = Statistics::LineFit\->new();
\& $lineFit = Statistics::LineFit\->new($validate);
\& $lineFit = Statistics::LineFit\->new($validate, $hush);
\&
\& $validate = 1 \-> Verify input data is numeric (slower execution)
\&             0 \-> Don\*(Aqt verify input data (default, faster execution)
\& $hush = 1 \-> Suppress error messages
\&       = 0 \-> Enable error messages (default)
.Ve
.SS "\fIcoefficients()\fP \- Return the slope and y intercept"
.IX Subsection "coefficients() - Return the slope and y intercept"
.Vb 1
\& ($intercept, $slope) = $lineFit\->coefficients();
.Ve
.PP
The returned list is undefined if the regression fails.
.SS "\fIdurbinWatson()\fP \- Return the Durbin-Watson statistic"
.IX Subsection "durbinWatson() - Return the Durbin-Watson statistic"
.Vb 1
\& $durbinWatson = $lineFit\->durbinWatson();
.Ve
.PP
The Durbin-Watson test is a test for first-order autocorrelation in
the residuals of a time series regression. The Durbin-Watson statistic
has a range of 0 to 4; a value of 2 indicates there is no
autocorrelation.
.PP
The return value is undefined if the regression fails.  If weights are
input, the return value is the weighted Durbin-Watson statistic.
.SS "\fImeanSqError()\fP \- Return the mean squared error"
.IX Subsection "meanSqError() - Return the mean squared error"
.Vb 1
\& $meanSquaredError = $lineFit\->meanSqError();
.Ve
.PP
The return value is undefined if the regression fails.  If weights are
input, the return value is the weighted mean squared error.
.SS "\fIpredictedYs()\fP \- Return the predicted y values"
.IX Subsection "predictedYs() - Return the predicted y values"
.Vb 1
\& @predictedYs = $lineFit\->predictedYs();
.Ve
.PP
The returned list is undefined if the regression fails.
.SS "\fIregress()\fP \- Do the least squares line fit (if not already done)"
.IX Subsection "regress() - Do the least squares line fit (if not already done)"
.Vb 1
\& $lineFit\->regress() or die "Regression failed"
.Ve
.PP
You don't need to call this method because it is invoked by the other
methods as needed.  After you call \fIsetData()\fR, you can call \fIregress()\fR
at any time to get the status of the regression for the current data.
.SS "\fIresiduals()\fP \- Return predicted y values minus input y values"
.IX Subsection "residuals() - Return predicted y values minus input y values"
.Vb 1
\& @residuals = $lineFit\->residuals();
.Ve
.PP
The returned list is undefined if the regression fails.
.SS "\fIrSquared()\fP \- Return the square of the correlation coefficient"
.IX Subsection "rSquared() - Return the square of the correlation coefficient"
.Vb 1
\& $rSquared = $lineFit\->rSquared();
.Ve
.PP
R squared, also called the square of the Pearson product-moment correlation
coefficient, is a measure of goodness-of-fit.  It is the fraction of the
variation in Y that can be attributed to the variation in X.  A perfect fit
will have an R squared of 1; fitting a line to the vertices of a
regular polygon will yield an R squared of zero.  Graphical displays of data
with an R squared of less than about 0.1 do not show a visible linear trend.
.PP
The return value is undefined if the regression fails.  If weights are 
input, the return value is the weighted correlation coefficient.
.SS "\fIsetData()\fP \- Initialize (x,y) values and optional weights"
.IX Subsection "setData() - Initialize (x,y) values and optional weights"
.Vb 4
\& $lineFit\->setData(\e@x, \e@y) or die "Invalid regression data";
\& $lineFit\->setData(\e@x, \e@y, \e@weights) or die "Invalid regression data";
\& $lineFit\->setData(\e@xy) or die "Invalid regression data";
\& $lineFit\->setData(\e@xy, \e@weights) or die "Invalid regression data";
.Ve
.PP
\&\f(CW@xy\fR is an array of arrayrefs; x values are \f(CW$xy\fR[$i][0], y values are
\&\f(CW$xy\fR[$i][1].  (The module does not access any indices greater than \f(CW$xy\fR[$i][1],
so the arrayrefs can point to arrays that are longer than two elements.)
The method identifies the difference between the first and fourth calling
signatures by examining the first argument.
.PP
The optional weights array must be the same length as the data array(s).
The weights must be non-negative numbers; at least two of the weights
must be nonzero.  Only the relative size of the weights is significant:
the program normalizes the weights (after copying the input values) so
that the sum of the weights equals the number of points.  If you want to
do multiple line fits using the same weights, the weights must be passed
to each call to \fIsetData()\fR.
.PP
The method will return zero if the array lengths don't match, there are
less than two data points, any weights are negative or less than two of
the weights are nonzero. If the \fInew()\fR method was called with validate = 1,
the method will also verify that the data and weights are valid numbers.
Once you successfully call \fIsetData()\fR, the next call to any method other than
\&\fInew()\fR or \fIsetData()\fR invokes the regression.  You can modify the input data
or weights after calling \fIsetData()\fR without affecting the module's results.
.SS "\fIsigma()\fP \- Return the standard error of the estimate"
.IX Subsection "sigma() - Return the standard error of the estimate"
\&\f(CW$sigma\fR = \f(CW$lineFit\fR\->\fIsigma()\fR;
.PP
Sigma is an estimate of the homoscedastic standard deviation of the
error.  Sigma is also known as the standard error of the estimate.
.PP
The return value is undefined if the regression fails.  If weights are
input, the return value is the weighted standard error.
.SS "\fItStatistics()\fP \- Return the t statistics"
.IX Subsection "tStatistics() - Return the t statistics"
.Vb 1
\& (tStatIntercept, $tStatSlope) = $lineFit\->tStatistics();
.Ve
.PP
The t statistic, also called the t ratio or Wald statistic, is used to
accept or reject a hypothesis using a table of cutoff values computed from
the t distribution.  The t\-statistic suggests that the estimated value is
(reasonable, too small, too large) when the t\-statistic is (close to zero,
large and positive, large and negative).
.PP
The returned list is undefined if the regression fails.  If weights 
are input, the returned values are the weighted t statistics.
.SS "\fIvarianceOfEstimates()\fP \- Return variances of estimates of intercept, slope"
.IX Subsection "varianceOfEstimates() - Return variances of estimates of intercept, slope"
.Vb 1
\& (varianceIntercept, $varianceSlope) = $lineFit\->varianceOfEstimates();
.Ve
.PP
Assuming the data are noisy or inaccurate, the intercept and slope returned
by the \fIcoefficients()\fR method are only estimates of the true intercept and 
slope.  The \fIvarianceofEstimate()\fR method returns the variances of the 
estimates of the intercept and slope, respectively.  See Numerical Recipes
in C, section 15.2 (Fitting Data to a Straight Line), equation 15.2.9.
.PP
The returned list is undefined if the regression fails.  If weights 
are input, the returned values are the weighted variances.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 8
\& Mendenhall, W., and Sincich, T.L., 2003, A Second Course in Statistics:
\&   Regression Analysis, 6th ed., Prentice Hall.
\& Press, W. H., Flannery, B. P., Teukolsky, S. A., Vetterling, W. T., 1992,
\&   Numerical Recipes in C : The Art of Scientific Computing, 2nd ed., 
\&   Cambridge University Press.
\& The man page for perl(1).
\& The CPAN modules Statistics::OLS, Statistics::GaussHelmert and 
\&   Statistics::Regression.
.Ve
.PP
Statistics::LineFit is simpler to use than Statistics::GaussHelmert or
Statistics::Regression.  Statistics::LineFit was inspired by and borrows some
ideas from the venerable Statistics::OLS module.
.PP
The significant differences
between Statistics::LineFit and Statistics::OLS (version 0.07) are:
.IP "\fBStatistics::LineFit is more robust.\fR" 4
.IX Item "Statistics::LineFit is more robust."
Statistics::OLS returns incorrect results for certain input datasets. 
Statistics::OLS does not deep copy its input arrays, which can lead
to subtle bugs.  The Statistics::OLS installation test has only one
test and does not verify that the regression returns correct results.
In contrast, Statistics::LineFit has over 200 installation tests that use
various datasets/calling sequences to verify the accuracy of the
regression to within 1.0e\-10.
.IP "\fBStatistics::LineFit is faster.\fR" 4
.IX Item "Statistics::LineFit is faster."
For a sequence of calls to \fInew()\fR, setData(\e@x, \e@y) and \fIregress()\fR,
Statistics::LineFit is faster than Statistics::OLS by factors of 2.0, 1.6
and 2.4 for array lengths of 5, 100 and 10000, respectively.
.IP "\fBStatistics::LineFit can do weighted or unweighted regression.\fR" 4
.IX Item "Statistics::LineFit can do weighted or unweighted regression."
Statistics::OLS lacks this option.
.IP "\fBStatistics::LineFit has a better interface.\fR" 4
.IX Item "Statistics::LineFit has a better interface."
Once you call the \fIStatistics::LineFit::setData()\fR method, you can call the
other methods in any order and call methods multiple times without invoking
redundant calculations.  Statistics::LineFit lets you enable or disable
data verification or error messages.
.IP "\fBStatistics::LineFit has better code and documentation.\fR" 4
.IX Item "Statistics::LineFit has better code and documentation."
The code in Statistics::LineFit is more readable, more object oriented and
more compliant with Perl coding standards than the code in Statistics::OLS.
The documentation for Statistics::LineFit is more detailed and complete.
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Anderson, cpan(\s-1AT\s0)richardanderson(\s-1DOT\s0)org,
http://www.richardanderson.org
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
The full text of the license can be found in the \s-1LICENSE\s0 file included in
the distribution and available in the \s-1CPAN\s0 listing for Statistics::LineFit
(see www.cpan.org or search.cpan.org).
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
To the maximum extent permitted by applicable law, the author of this
module disclaims all warranties, either express or implied, including
but not limited to implied warranties of merchantability and fitness for
a particular purpose, with regard to the software and the accompanying
documentation.
