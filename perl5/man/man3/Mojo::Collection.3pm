.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Collection 3"
.TH Mojo::Collection 3 "2014-02-13" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Collection \- Collection
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Collection;
\&
\&  # Manipulate collection
\&  my $collection = Mojo::Collection\->new(qw(just works));
\&  unshift @$collection, \*(Aqit\*(Aq;
\&
\&  # Chain methods
\&  $collection\->map(sub { ucfirst })\->shuffle\->each(sub {
\&    my ($word, $count) = @_;
\&    say "$count: $word";
\&  });
\&
\&  # Stringify collection
\&  say $collection\->join("\en");
\&  say "$collection";
\&
\&  # Use the alternative constructor
\&  use Mojo::Collection \*(Aqc\*(Aq;
\&  c(qw(a b c))\->join(\*(Aq/\*(Aq)\->url_escape\->say;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Collection is an array-based container for collections.
.PP
.Vb 4
\&  # Access array directly to manipulate collection
\&  my $collection = Mojo::Collection\->new(1 .. 25);
\&  $collection\->[23] += 100;
\&  say for @$collection;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Mojo::Collection implements the following functions, which can be imported
individually.
.SS "c"
.IX Subsection "c"
.Vb 1
\&  my $collection = c(1, 2, 3);
.Ve
.PP
Construct a new array-based Mojo::Collection object.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Collection implements the following methods.
.SS "compact"
.IX Subsection "compact"
.Vb 1
\&  my $new = $collection\->compact;
.Ve
.PP
Create a new collection with all elements that are defined and not an empty
string.
.SS "each"
.IX Subsection "each"
.Vb 2
\&  my @elements = $collection\->each;
\&  $collection  = $collection\->each(sub {...});
.Ve
.PP
Evaluate callback for each element in collection or return all elements as a
list if none has been provided. The element will be the first argument passed
to the callback and is also available as \f(CW$_\fR.
.PP
.Vb 4
\&  $collection\->each(sub {
\&    my ($e, $count) = @_;
\&    say "$count: $e";
\&  });
.Ve
.SS "first"
.IX Subsection "first"
.Vb 3
\&  my $first = $collection\->first;
\&  my $first = $collection\->first(qr/foo/);
\&  my $first = $collection\->first(sub {...});
.Ve
.PP
Evaluate regular expression or callback for each element in collection and
return the first one that matched the regular expression, or for which the
callback returned true. The element will be the first argument passed to the
callback and is also available as \f(CW$_\fR.
.PP
.Vb 1
\&  my $five = $collection\->first(sub { $_ == 5 });
.Ve
.SS "flatten"
.IX Subsection "flatten"
.Vb 1
\&  my $new = $collection\->flatten;
.Ve
.PP
Flatten nested collections/arrays recursively and create a new collection with
all elements.
.SS "grep"
.IX Subsection "grep"
.Vb 2
\&  my $new = $collection\->grep(qr/foo/);
\&  my $new = $collection\->grep(sub {...});
.Ve
.PP
Evaluate regular expression or callback for each element in collection and
create a new collection with all elements that matched the regular expression,
or for which the callback returned true. The element will be the first
argument passed to the callback and is also available as \f(CW$_\fR.
.PP
.Vb 1
\&  my $interesting = $collection\->grep(qr/mojo/i);
.Ve
.SS "join"
.IX Subsection "join"
.Vb 2
\&  my $stream = $collection\->join;
\&  my $stream = $collection\->join("\en");
.Ve
.PP
Turn collection into Mojo::ByteStream.
.PP
.Vb 1
\&  $collection\->join("\en")\->say;
.Ve
.SS "last"
.IX Subsection "last"
.Vb 1
\&  my $last = $collection\->last;
.Ve
.PP
Return the last element in collection.
.SS "map"
.IX Subsection "map"
.Vb 1
\&  my $new = $collection\->map(sub {...});
.Ve
.PP
Evaluate callback for each element in collection and create a new collection
from the results. The element will be the first argument passed to the
callback and is also available as \f(CW$_\fR.
.PP
.Vb 1
\&  my $doubled = $collection\->map(sub { $_ * 2 });
.Ve
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $collection = Mojo::Collection\->new(1, 2, 3);
.Ve
.PP
Construct a new array-based Mojo::Collection object.
.SS "pluck"
.IX Subsection "pluck"
.Vb 2
\&  my $new = $collection\->pluck($method);
\&  my $new = $collection\->pluck($method, @args);
.Ve
.PP
Call method on each element in collection and create a new collection from the
results.
.PP
.Vb 2
\&  # Equal to but more convenient than
\&  my $new = $collection\->map(sub { $_\->$method(@args) });
.Ve
.SS "reverse"
.IX Subsection "reverse"
.Vb 1
\&  my $new = $collection\->reverse;
.Ve
.PP
Create a new collection with all elements in reverse order.
.SS "slice"
.IX Subsection "slice"
.Vb 1
\&  my $new = $collection\->slice(4 .. 7);
.Ve
.PP
Create a new collection with all selected elements.
.SS "shuffle"
.IX Subsection "shuffle"
.Vb 1
\&  my $new = $collection\->shuffle;
.Ve
.PP
Create a new collection with all elements in random order.
.SS "size"
.IX Subsection "size"
.Vb 1
\&  my $size = $collection\->size;
.Ve
.PP
Number of elements in collection.
.SS "sort"
.IX Subsection "sort"
.Vb 2
\&  my $new = $collection\->sort;
\&  my $new = $collection\->sort(sub {...});
.Ve
.PP
Sort elements based on return value of callback and create a new collection
from the results.
.PP
.Vb 1
\&  my $insensitive = $collection\->sort(sub { uc(shift) cmp uc(shift) });
.Ve
.SS "tap"
.IX Subsection "tap"
.Vb 1
\&  $collection = $collection\->tap(sub {...});
.Ve
.PP
Alias for \*(L"tap\*(R" in Mojo::Base.
.SS "uniq"
.IX Subsection "uniq"
.Vb 1
\&  my $new = $collection\->uniq;
.Ve
.PP
Create a new collection without duplicate elements.
.SH "AUTOLOAD"
.IX Header "AUTOLOAD"
In addition to the \*(L"\s-1METHODS\s0\*(R" above, you can also call methods provided by
all elements in the collection directly and create a new collection from the
results, similar to \*(L"pluck\*(R".
.PP
.Vb 2
\&  push @$collection, Mojo::DOM\->new("<div><h1>$_</h1></div>") for 1 .. 9;
\&  say $collection\->find(\*(Aqh1\*(Aq)\->type(\*(Aqh2\*(Aq)\->prepend_content(\*(AqTest \*(Aq)\->root;
.Ve
.SH "OPERATORS"
.IX Header "OPERATORS"
Mojo::Collection overloads the following operators.
.SS "bool"
.IX Subsection "bool"
.Vb 1
\&  my $bool = !!$collection;
.Ve
.PP
Always true.
.SS "stringify"
.IX Subsection "stringify"
.Vb 1
\&  my $str = "$collection";
.Ve
.PP
Stringify elements in collection and \*(L"join\*(R" them with newlines.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
