.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.30)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::Reactor::EV 3"
.TH Mojo::Reactor::EV 3 "2015-04-26" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Reactor::EV \- Low\-level event reactor with libev support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Reactor::EV;
\&
\&  # Watch if handle becomes readable or writable
\&  my $reactor = Mojo::Reactor::EV\->new;
\&  $reactor\->io($first => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqFirst handle is writable\*(Aq : \*(AqFirst handle is readable\*(Aq;
\&  });
\&
\&  # Change to watching only if handle becomes writable
\&  $reactor\->watch($first, 0, 1);
\&
\&  # Turn file descriptor into handle and watch if it becomes readable
\&  my $second = IO::Handle\->new_from_fd($fd, \*(Aqr\*(Aq);
\&  $reactor\->io($second => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqSecond handle is writable\*(Aq : \*(AqSecond handle is readable\*(Aq;
\&  })\->watch($second, 1, 0);
\&
\&  # Add a timer
\&  $reactor\->timer(15 => sub {
\&    my $reactor = shift;
\&    $reactor\->remove($first);
\&    $reactor\->remove($second);
\&    say \*(AqTimeout!\*(Aq;
\&  });
\&
\&  # Start reactor if necessary
\&  $reactor\->start unless $reactor\->is_running;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Reactor::EV is a low-level event reactor based on \s-1EV\s0 (4.0+).
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::Reactor::EV inherits all events from Mojo::Reactor::Poll.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Reactor::EV inherits all methods from Mojo::Reactor::Poll and
implements the following new ones.
.SS "again"
.IX Subsection "again"
.Vb 1
\&  $reactor\->again($id);
.Ve
.PP
Restart timer. Note that this method requires an active timer.
.SS "is_running"
.IX Subsection "is_running"
.Vb 1
\&  my $bool = $reactor\->is_running;
.Ve
.PP
Check if reactor is running.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $reactor = Mojo::Reactor::EV\->new;
.Ve
.PP
Construct a new Mojo::Reactor::EV object.
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 1
\&  $reactor\->one_tick;
.Ve
.PP
Run reactor until an event occurs or no events are being watched anymore. Note
that this method can recurse back into the reactor, so you need to be careful.
.PP
.Vb 4
\&  # Don\*(Aqt block longer than 0.5 seconds
\&  my $id = $reactor\->timer(0.5 => sub {});
\&  $reactor\->one_tick;
\&  $reactor\->remove($id);
.Ve
.SS "recurring"
.IX Subsection "recurring"
.Vb 1
\&  my $id = $reactor\->recurring(0.25 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds.
.SS "start"
.IX Subsection "start"
.Vb 1
\&  $reactor\->start;
.Ve
.PP
Start watching for I/O and timer events, this will block until \*(L"stop\*(R" is
called or no events are being watched anymore.
.PP
.Vb 2
\&  # Start reactor only if it is not running already
\&  $reactor\->start unless $reactor\->is_running;
.Ve
.SS "stop"
.IX Subsection "stop"
.Vb 1
\&  $reactor\->stop;
.Ve
.PP
Stop watching for I/O and timer events.
.SS "timer"
.IX Subsection "timer"
.Vb 1
\&  my $id = $reactor\->timer(0.5 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds.
.SS "watch"
.IX Subsection "watch"
.Vb 1
\&  $reactor = $reactor\->watch($handle, $readable, $writable);
.Ve
.PP
Change I/O events to watch handle for with true and false values. Note that
this method requires an active I/O watcher.
.PP
.Vb 2
\&  # Watch only for readable events
\&  $reactor\->watch($handle, 1, 0);
\&
\&  # Watch only for writable events
\&  $reactor\->watch($handle, 0, 1);
\&
\&  # Watch for readable and writable events
\&  $reactor\->watch($handle, 1, 1);
\&
\&  # Pause watching for events
\&  $reactor\->watch($handle, 0, 0);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
