.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.30)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::Template 3"
.TH Mojo::Template 3 "2015-05-25" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Template \- Perl\-ish templates!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Template;
\&
\&  # Simple
\&  my $mt = Mojo::Template\->new;
\&  my $output = $mt\->render(<<\*(AqEOF\*(Aq);
\&  % use Time::Piece;
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Simple</title></head>
\&    % my $now = localtime;
\&    <body>Time: <%= $now\->hms %></body>
\&  </html>
\&  EOF
\&  say $output;
\&
\&  # More advanced
\&  my $output = $mt\->render(<<\*(AqEOF\*(Aq, 23, \*(AqMore advanced\*(Aq);
\&  % my ($num, $title) = @_;
\&  %= 5 * 5
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title><%= $title %></title></head>
\&    <body>
\&      test 123
\&      foo <% my $i = $num + 2; %>
\&      % for (1 .. 23) {
\&      * some text <%= $i++ %>
\&      % }
\&    </body>
\&  </html>
\&  EOF
\&  say $output;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Template is a minimalistic and very Perl-ish template engine, designed
specifically for all those small tasks that come up during big projects. Like
preprocessing a configuration file, generating text from heredocs and stuff
like that.
.PP
See Mojolicious::Guides::Rendering for information on how to generate
content with the Mojolicious renderer.
.SH "SYNTAX"
.IX Header "SYNTAX"
For all templates strict, warnings, utf8 and Perl 5.10 features are
automatically enabled.
.PP
.Vb 10
\&  <% Perl code %>
\&  <%= Perl expression, replaced with result %>
\&  <%== Perl expression, replaced with XML escaped result %>
\&  <%# Comment, useful for debugging %>
\&  <%% Replaced with "<%", useful for generating templates %>
\&  % Perl code line, treated as "<% line =%>" (explained later)
\&  %= Perl expression line, treated as "<%= line %>"
\&  %== Perl expression line, treated as "<%== line %>"
\&  %# Comment line, useful for debugging
\&  %% Replaced with "%", useful for generating templates
.Ve
.PP
Escaping behavior can be reversed with the \*(L"auto_escape\*(R" attribute, this is
the default in Mojolicious \f(CW\*(C`.ep\*(C'\fR templates for example.
.PP
.Vb 2
\&  <%= Perl expression, replaced with XML escaped result %>
\&  <%== Perl expression, replaced with result %>
.Ve
.PP
Mojo::ByteStream objects are always excluded from automatic escaping.
.PP
.Vb 2
\&  % use Mojo::ByteStream \*(Aqb\*(Aq;
\&  <%= b(\*(Aq<div>excluded!</div>\*(Aq) %>
.Ve
.PP
Whitespace characters around tags can be trimmed by adding an additional equal
sign to the end of a tag.
.PP
.Vb 3
\&  <% for (1 .. 3) { %>
\&    <%= \*(AqTrim all whitespace characters around this expression\*(Aq =%>
\&  <% } %>
.Ve
.PP
Newline characters can be escaped with a backslash.
.PP
.Vb 2
\&  This is <%= 1 + 1 %> a\e
\&  single line
.Ve
.PP
And a backslash in front of a newline character can be escaped with another
backslash.
.PP
.Vb 3
\&  This will <%= 1 + 1 %> result\e\e
\&  in multiple\e\e
\&  lines
.Ve
.PP
You can capture whole template blocks for reuse later with the \f(CW\*(C`begin\*(C'\fR and
\&\f(CW\*(C`end\*(C'\fR keywords. Just be aware that both keywords are part of the surrounding
tag and not actual Perl code, so there can only be whitespace after \f(CW\*(C`begin\*(C'\fR
and before \f(CW\*(C`end\*(C'\fR.
.PP
.Vb 6
\&  <% my $block = begin %>
\&    <% my $name = shift; =%>
\&    Hello <%= $name %>.
\&  <% end %>
\&  <%= $block\->(\*(AqBaerbel\*(Aq) %>
\&  <%= $block\->(\*(AqWolfgang\*(Aq) %>
.Ve
.PP
Perl lines can also be indented freely.
.PP
.Vb 6
\&  % my $block = begin
\&    % my $name = shift;
\&    Hello <%= $name %>.
\&  % end
\&  %= $block\->(\*(AqBaerbel\*(Aq)
\&  %= $block\->(\*(AqWolfgang\*(Aq)
.Ve
.PP
Mojo::Template templates get compiled to a Perl subroutine, that means you
can access arguments simply via \f(CW@_\fR.
.PP
.Vb 3
\&  % my ($foo, $bar) = @_;
\&  % my $x = shift;
\&  test 123 <%= $foo %>
.Ve
.PP
The compilation of templates to Perl code can make debugging a bit tricky, but
Mojo::Template will return Mojo::Exception objects that stringify to
error messages with context.
.PP
.Vb 6
\&  Bareword "xx" not allowed while "strict subs" in use at template line 4.
\&  2: </head>
\&  3: <body>
\&  4: % my $i = 2; xx
\&  5: %= $i * 2
\&  6: </body>
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::Template implements the following attributes.
.SS "auto_escape"
.IX Subsection "auto_escape"
.Vb 2
\&  my $bool = $mt\->auto_escape;
\&  $mt      = $mt\->auto_escape($bool);
.Ve
.PP
Activate automatic escaping.
.SS "append"
.IX Subsection "append"
.Vb 2
\&  my $code = $mt\->append;
\&  $mt      = $mt\->append(\*(Aqwarn "Processed template"\*(Aq);
.Ve
.PP
Append Perl code to compiled template. Note that this code should not contain
newline characters, or line numbers in error messages might end up being wrong.
.SS "capture_end"
.IX Subsection "capture_end"
.Vb 2
\&  my $end = $mt\->capture_end;
\&  $mt     = $mt\->capture_end(\*(Aqend\*(Aq);
.Ve
.PP
Keyword indicating the end of a capture block, defaults to \f(CW\*(C`end\*(C'\fR.
.PP
.Vb 3
\&  <% my $block = begin %>
\&    Some data!
\&  <% end %>
.Ve
.SS "capture_start"
.IX Subsection "capture_start"
.Vb 2
\&  my $start = $mt\->capture_start;
\&  $mt       = $mt\->capture_start(\*(Aqbegin\*(Aq);
.Ve
.PP
Keyword indicating the start of a capture block, defaults to \f(CW\*(C`begin\*(C'\fR.
.PP
.Vb 3
\&  <% my $block = begin %>
\&    Some data!
\&  <% end %>
.Ve
.SS "code"
.IX Subsection "code"
.Vb 2
\&  my $code = $mt\->code;
\&  $mt      = $mt\->code($code);
.Ve
.PP
Perl code for template.
.SS "comment_mark"
.IX Subsection "comment_mark"
.Vb 2
\&  my $mark = $mt\->comment_mark;
\&  $mt      = $mt\->comment_mark(\*(Aq#\*(Aq);
.Ve
.PP
Character indicating the start of a comment, defaults to \f(CW\*(C`#\*(C'\fR.
.PP
.Vb 1
\&  <%# This is a comment %>
.Ve
.SS "compiled"
.IX Subsection "compiled"
.Vb 2
\&  my $compiled = $mt\->compiled;
\&  $mt          = $mt\->compiled($compiled);
.Ve
.PP
Compiled template code.
.SS "encoding"
.IX Subsection "encoding"
.Vb 2
\&  my $encoding = $mt\->encoding;
\&  $mt          = $mt\->encoding(\*(AqUTF\-8\*(Aq);
.Ve
.PP
Encoding used for template files.
.SS "escape"
.IX Subsection "escape"
.Vb 2
\&  my $cb = $mt\->escape;
\&  $mt    = $mt\->escape(sub {...});
.Ve
.PP
A callback used to escape the results of escaped expressions, defaults to
\&\*(L"xss_escape\*(R" in Mojo::Util.
.PP
.Vb 4
\&  $mt\->escape(sub {
\&    my $str = shift;
\&    return reverse $str;
\&  });
.Ve
.SS "escape_mark"
.IX Subsection "escape_mark"
.Vb 2
\&  my $mark = $mt\->escape_mark;
\&  $mt      = $mt\->escape_mark(\*(Aq=\*(Aq);
.Ve
.PP
Character indicating the start of an escaped expression, defaults to \f(CW\*(C`=\*(C'\fR.
.PP
.Vb 1
\&  <%== $foo %>
.Ve
.SS "expression_mark"
.IX Subsection "expression_mark"
.Vb 2
\&  my $mark = $mt\->expression_mark;
\&  $mt      = $mt\->expression_mark(\*(Aq=\*(Aq);
.Ve
.PP
Character indicating the start of an expression, defaults to \f(CW\*(C`=\*(C'\fR.
.PP
.Vb 1
\&  <%= $foo %>
.Ve
.SS "line_start"
.IX Subsection "line_start"
.Vb 2
\&  my $start = $mt\->line_start;
\&  $mt       = $mt\->line_start(\*(Aq%\*(Aq);
.Ve
.PP
Character indicating the start of a code line, defaults to \f(CW\*(C`%\*(C'\fR.
.PP
.Vb 1
\&  % $foo = 23;
.Ve
.SS "name"
.IX Subsection "name"
.Vb 2
\&  my $name = $mt\->name;
\&  $mt      = $mt\->name(\*(Aqfoo.mt\*(Aq);
.Ve
.PP
Name of template currently being processed, defaults to \f(CW\*(C`template\*(C'\fR. Note that
this value should not contain quotes or newline characters, or error messages
might end up being wrong.
.SS "namespace"
.IX Subsection "namespace"
.Vb 2
\&  my $namespace = $mt\->namespace;
\&  $mt           = $mt\->namespace(\*(Aqmain\*(Aq);
.Ve
.PP
Namespace used to compile templates, defaults to \f(CW\*(C`Mojo::Template::SandBox\*(C'\fR.
Note that namespaces should only be shared very carefully between templates,
since functions and global variables will not be cleared automatically.
.SS "prepend"
.IX Subsection "prepend"
.Vb 2
\&  my $code = $mt\->prepend;
\&  $mt      = $mt\->prepend(\*(Aqmy $self = shift;\*(Aq);
.Ve
.PP
Prepend Perl code to compiled template. Note that this code should not contain
newline characters, or line numbers in error messages might end up being wrong.
.SS "replace_mark"
.IX Subsection "replace_mark"
.Vb 2
\&  my $mark = $mt\->replace_mark;
\&  $mt      = $mt\->replace_mark(\*(Aq%\*(Aq);
.Ve
.PP
Character used for escaping the start of a tag or line, defaults to \f(CW\*(C`%\*(C'\fR.
.PP
.Vb 1
\&  <%% my $foo = 23; %>
.Ve
.SS "tag_start"
.IX Subsection "tag_start"
.Vb 2
\&  my $start = $mt\->tag_start;
\&  $mt       = $mt\->tag_start(\*(Aq<%\*(Aq);
.Ve
.PP
Characters indicating the start of a tag, defaults to \f(CW\*(C`<%\*(C'\fR.
.PP
.Vb 1
\&  <% $foo = 23; %>
.Ve
.SS "tag_end"
.IX Subsection "tag_end"
.Vb 2
\&  my $end = $mt\->tag_end;
\&  $mt     = $mt\->tag_end(\*(Aq%>\*(Aq);
.Ve
.PP
Characters indicating the end of a tag, defaults to \f(CW\*(C`%>\*(C'\fR.
.PP
.Vb 1
\&  <%= $foo %>
.Ve
.SS "tree"
.IX Subsection "tree"
.Vb 2
\&  my $tree = $mt\->tree;
\&  $mt      = $mt\->tree([[\*(Aqtext\*(Aq, \*(Aqfoo\*(Aq], [\*(Aqline\*(Aq]]);
.Ve
.PP
Template in parsed form. Note that this structure should only be used very
carefully since it is very dynamic.
.SS "trim_mark"
.IX Subsection "trim_mark"
.Vb 2
\&  my $mark = $mt\->trim_mark;
\&  $mt      = $mt\->trim_mark(\*(Aq\-\*(Aq);
.Ve
.PP
Character activating automatic whitespace trimming, defaults to \f(CW\*(C`=\*(C'\fR.
.PP
.Vb 1
\&  <%= $foo =%>
.Ve
.SS "unparsed"
.IX Subsection "unparsed"
.Vb 2
\&  my $unparsed = $mt\->unparsed;
\&  $mt          = $mt\->unparsed(\*(Aq<%= 1 + 1 %>\*(Aq);
.Ve
.PP
Raw unparsed template.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Template inherits all methods from Mojo::Base and implements the
following new ones.
.SS "build"
.IX Subsection "build"
.Vb 1
\&  $mt = $mt\->build;
.Ve
.PP
Build Perl \*(L"code\*(R" from \*(L"tree\*(R".
.SS "compile"
.IX Subsection "compile"
.Vb 1
\&  my $exception = $mt\->compile;
.Ve
.PP
Compile Perl \*(L"code\*(R" for template.
.SS "interpret"
.IX Subsection "interpret"
.Vb 2
\&  my $output = $mt\->interpret;
\&  my $output = $mt\->interpret(@args);
.Ve
.PP
Interpret \*(L"compiled\*(R" template code.
.PP
.Vb 4
\&  # Reuse template
\&  say $mt\->render(\*(AqHello <%= $_[0] %>!\*(Aq, \*(AqBender\*(Aq);
\&  say $mt\->interpret(\*(AqFry\*(Aq);
\&  say $mt\->interpret(\*(AqLeela\*(Aq);
.Ve
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $mt = $mt\->parse(\*(Aq<%= 1 + 1 %>\*(Aq);
.Ve
.PP
Parse template into \*(L"tree\*(R".
.SS "render"
.IX Subsection "render"
.Vb 2
\&  my $output = $mt\->render(\*(Aq<%= 1 + 1 %>\*(Aq);
\&  my $output = $mt\->render(\*(Aq<%= shift() + shift() %>\*(Aq, @args);
.Ve
.PP
Render template.
.PP
.Vb 1
\&  say $mt\->render(\*(AqHello <%= $_[0] %>!\*(Aq, \*(AqBender\*(Aq);
.Ve
.SS "render_file"
.IX Subsection "render_file"
.Vb 2
\&  my $output = $mt\->render_file(\*(Aq/tmp/foo.mt\*(Aq);
\&  my $output = $mt\->render_file(\*(Aq/tmp/foo.mt\*(Aq, @args);
.Ve
.PP
Render template file.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`MOJO_TEMPLATE_DEBUG\*(C'\fR environment variable to get some
advanced diagnostics information printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_TEMPLATE_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
