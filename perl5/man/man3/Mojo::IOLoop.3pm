.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::IOLoop 3"
.TH Mojo::IOLoop 3 "2014-09-12" "perl v5.20.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::IOLoop \- Minimalistic event loop
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::IOLoop;
\&
\&  # Listen on port 3000
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $bytes) = @_;
\&
\&      # Process input chunk
\&      say $bytes;
\&
\&      # Write response
\&      $stream\->write(\*(AqHTTP/1.1 200 OK\*(Aq);
\&    });
\&  });
\&
\&  # Connect to port 3000
\&  my $id = Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $bytes) = @_;
\&
\&      # Process input
\&      say "Input: $bytes";
\&    });
\&
\&    # Write request
\&    $stream\->write("GET / HTTP/1.1\ex0d\ex0a\ex0d\ex0a");
\&  });
\&
\&  # Add a timer
\&  Mojo::IOLoop\->timer(5 => sub {
\&    my $loop = shift;
\&    $loop\->remove($id);
\&  });
\&
\&  # Start event loop if necessary
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::IOLoop is a very minimalistic event loop based on Mojo::Reactor,
it has been reduced to the absolute minimal feature set required to build
solid and scalable non-blocking \s-1TCP\s0 clients and servers.
.PP
Depending on operating system, the default per-process and system-wide file
descriptor limits are often very low and need to be tuned for better
scalability. The \f(CW\*(C`LIBEV_FLAGS\*(C'\fR environment variable should also be used to
select the best possible \s-1EV\s0 backend, which usually defaults to the not very
scalable \f(CW\*(C`select\*(C'\fR.
.PP
.Vb 4
\&  LIBEV_FLAGS=1   # select
\&  LIBEV_FLAGS=2   # poll
\&  LIBEV_FLAGS=4   # epoll (Linux)
\&  LIBEV_FLAGS=8   # kqueue (*BSD, OS X)
.Ve
.PP
The event loop will be resilient to time jumps if a monotonic clock is
available through Time::HiRes. A \s-1TLS\s0 certificate and key are also built
right in, to make writing test servers as easy as possible. Also note that for
convenience the \f(CW\*(C`PIPE\*(C'\fR signal will be set to \f(CW\*(C`IGNORE\*(C'\fR when Mojo::IOLoop
is loaded.
.PP
For better scalability (epoll, kqueue) and to provide IPv6, \s-1SOCKS5\s0 as well as
\&\s-1TLS\s0 support, the optional modules \s-1EV\s0 (4.0+), IO::Socket::IP (0.20+),
IO::Socket::Socks (0.64+) and IO::Socket::SSL (1.84+) will be used
automatically if they are installed. Individual features can also be disabled
with the \f(CW\*(C`MOJO_NO_IPV6\*(C'\fR, \f(CW\*(C`MOJO_NO_SOCKS\*(C'\fR and \f(CW\*(C`MOJO_NO_TLS\*(C'\fR environment
variables.
.PP
See \*(L"REAL-TIME \s-1WEB\*(R"\s0 in Mojolicious::Guides::Cookbook for more.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::IOLoop implements the following attributes.
.SS "accept_interval"
.IX Subsection "accept_interval"
.Vb 2
\&  my $interval = $loop\->accept_interval;
\&  $loop        = $loop\->accept_interval(0.5);
.Ve
.PP
Interval in seconds for trying to reacquire the accept mutex, defaults to
\&\f(CW0.025\fR. Note that changing this value can affect performance and idle \s-1CPU\s0
usage.
.SS "lock"
.IX Subsection "lock"
.Vb 2
\&  my $cb = $loop\->lock;
\&  $loop  = $loop\->lock(sub {...});
.Ve
.PP
A callback for acquiring the accept mutex, used to sync multiple server
processes. The callback should return true or false. Note that exceptions in
this callback are not captured.
.PP
.Vb 2
\&  $loop\->lock(sub {
\&    my $blocking = shift;
\&
\&    # Got the accept mutex, start accepting new connections
\&    return 1;
\&  });
.Ve
.SS "max_accepts"
.IX Subsection "max_accepts"
.Vb 2
\&  my $max = $loop\->max_accepts;
\&  $loop   = $loop\->max_accepts(1000);
.Ve
.PP
The maximum number of connections this event loop is allowed to accept before
shutting down gracefully without interrupting existing connections, defaults
to \f(CW0\fR. Setting the value to \f(CW0\fR will allow this event loop to accept new
connections indefinitely. Note that up to half of this value can be subtracted
randomly to improve load balancing between multiple server processes.
.SS "max_connections"
.IX Subsection "max_connections"
.Vb 2
\&  my $max = $loop\->max_connections;
\&  $loop   = $loop\->max_connections(1000);
.Ve
.PP
The maximum number of concurrent connections this event loop is allowed to
handle before stopping to accept new incoming connections, defaults to
\&\f(CW1000\fR. Setting the value to \f(CW0\fR will make this event loop stop accepting
new connections and allow it to shut down gracefully without interrupting
existing connections.
.SS "multi_accept"
.IX Subsection "multi_accept"
.Vb 2
\&  my $multi = $loop\->multi_accept;
\&  $loop     = $loop\->multi_accept(100);
.Ve
.PP
Number of connections to accept at once, defaults to \f(CW50\fR.
.SS "reactor"
.IX Subsection "reactor"
.Vb 2
\&  my $reactor = $loop\->reactor;
\&  $loop       = $loop\->reactor(Mojo::Reactor\->new);
.Ve
.PP
Low-level event reactor, usually a Mojo::Reactor::Poll or
Mojo::Reactor::EV object with a default subscriber to the event
\&\*(L"error\*(R" in Mojo::Reactor.
.PP
.Vb 5
\&  # Watch if handle becomes readable or writable
\&  $loop\->reactor\->io($handle => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqHandle is writable\*(Aq : \*(AqHandle is readable\*(Aq;
\&  });
\&
\&  # Change to watching only if handle becomes writable
\&  $loop\->reactor\->watch($handle, 0, 1);
.Ve
.SS "unlock"
.IX Subsection "unlock"
.Vb 2
\&  my $cb = $loop\->unlock;
\&  $loop  = $loop\->unlock(sub {...});
.Ve
.PP
A callback for releasing the accept mutex, used to sync multiple server
processes. Note that exceptions in this callback are not captured.
.SH "METHODS"
.IX Header "METHODS"
Mojo::IOLoop inherits all methods from Mojo::Base and implements the
following new ones.
.SS "acceptor"
.IX Subsection "acceptor"
.Vb 3
\&  my $server = Mojo::IOLoop\->acceptor($id);
\&  my $server = $loop\->acceptor($id);
\&  my $id     = $loop\->acceptor(Mojo::IOLoop::Server\->new);
.Ve
.PP
Get Mojo::IOLoop::Server object for id or turn object into an acceptor.
.SS "client"
.IX Subsection "client"
.Vb 4
\&  my $id
\&    = Mojo::IOLoop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client({address => \*(Aq127.0.0.1\*(Aq, port => 3000} => sub {...});
.Ve
.PP
Open \s-1TCP\s0 connection with Mojo::IOLoop::Client, takes the same arguments as
\&\*(L"connect\*(R" in Mojo::IOLoop::Client.
.PP
.Vb 5
\&  # Connect to localhost on port 3000
\&  Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&    ...
\&  });
.Ve
.SS "delay"
.IX Subsection "delay"
.Vb 4
\&  my $delay = Mojo::IOLoop\->delay;
\&  my $delay = $loop\->delay;
\&  my $delay = $loop\->delay(sub {...});
\&  my $delay = $loop\->delay(sub {...}, sub {...});
.Ve
.PP
Build Mojo::IOLoop::Delay object to manage callbacks and control the flow
of events for this event loop, which can help you avoid deep nested closures
and memory leaks that often result from continuation-passing style. Callbacks
will be passed along to \*(L"steps\*(R" in Mojo::IOLoop::Delay.
.PP
.Vb 10
\&  # Synchronize multiple events
\&  my $delay = Mojo::IOLoop\->delay(sub { say \*(AqBOOM!\*(Aq });
\&  for my $i (1 .. 10) {
\&    my $end = $delay\->begin;
\&    Mojo::IOLoop\->timer($i => sub {
\&      say 10 \- $i;
\&      $end\->();
\&    });
\&  }
\&  $delay\->wait;
\&
\&  # Sequentialize multiple events
\&  Mojo::IOLoop\->delay(
\&
\&    # First step (simple timer)
\&    sub {
\&      my $delay = shift;
\&      Mojo::IOLoop\->timer(2 => $delay\->begin);
\&      say \*(AqSecond step in 2 seconds.\*(Aq;
\&    },
\&
\&    # Second step (concurrent timers)
\&    sub {
\&      my $delay = shift;
\&      Mojo::IOLoop\->timer(1 => $delay\->begin);
\&      Mojo::IOLoop\->timer(3 => $delay\->begin);
\&      say \*(AqThird step in 3 seconds.\*(Aq;
\&    },
\&
\&    # Third step (the end)
\&    sub { say \*(AqAnd done after 5 seconds total.\*(Aq }
\&  )\->wait;
\&
\&  # Handle exceptions in all steps
\&  Mojo::IOLoop\->delay(
\&    sub {
\&      my $delay = shift;
\&      die \*(AqIntentional error\*(Aq;
\&    },
\&    sub {
\&      my ($delay, @args) = @_;
\&      say \*(AqNever actually reached.\*(Aq;
\&    }
\&  )\->catch(sub {
\&    my ($delay, $err) = @_;
\&    say "Something went wrong: $err";
\&  })\->wait;
.Ve
.SS "is_running"
.IX Subsection "is_running"
.Vb 2
\&  my $bool = Mojo::IOLoop\->is_running;
\&  my $bool = $loop\->is_running;
.Ve
.PP
Check if event loop is running.
.PP
.Vb 1
\&  exit unless Mojo::IOLoop\->is_running;
.Ve
.SS "next_tick"
.IX Subsection "next_tick"
.Vb 2
\&  my $undef = Mojo::IOLoop\->next_tick(sub {...});
\&  my $undef = $loop\->next_tick(sub {...});
.Ve
.PP
Invoke callback as soon as possible, but not before returning, always returns
\&\f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 5
\&  # Perform operation on next reactor tick
\&  Mojo::IOLoop\->next_tick(sub {
\&    my $loop = shift;
\&    ...
\&  });
.Ve
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 2
\&  Mojo::IOLoop\->one_tick;
\&  $loop\->one_tick;
.Ve
.PP
Run event loop until an event occurs. Note that this method can recurse back
into the reactor, so you need to be careful.
.PP
.Vb 4
\&  # Don\*(Aqt block longer than 0.5 seconds
\&  my $id = Mojo::IOLoop\->timer(0.5 => sub {});
\&  Mojo::IOLoop\->one_tick;
\&  Mojo::IOLoop\->remove($id);
.Ve
.SS "recurring"
.IX Subsection "recurring"
.Vb 3
\&  my $id = Mojo::IOLoop\->recurring(3 => sub {...});
\&  my $id = $loop\->recurring(0 => sub {...});
\&  my $id = $loop\->recurring(0.25 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds.
.PP
.Vb 5
\&  # Perform operation every 5 seconds
\&  Mojo::IOLoop\->recurring(5 => sub {
\&    my $loop = shift;
\&    ...
\&  });
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 2
\&  Mojo::IOLoop\->remove($id);
\&  $loop\->remove($id);
.Ve
.PP
Remove anything with an id, connections will be dropped gracefully by allowing
them to finish writing all data in their write buffers.
.SS "reset"
.IX Subsection "reset"
.Vb 2
\&  Mojo::IOLoop\->reset;
\&  $loop\->reset;
.Ve
.PP
Remove everything and stop the event loop.
.SS "server"
.IX Subsection "server"
.Vb 3
\&  my $id = Mojo::IOLoop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server({port => 3000} => sub {...});
.Ve
.PP
Accept \s-1TCP\s0 connections with Mojo::IOLoop::Server, takes the same arguments
as \*(L"listen\*(R" in Mojo::IOLoop::Server.
.PP
.Vb 5
\&  # Listen on port 3000
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream, $id) = @_;
\&    ...
\&  });
\&
\&  # Listen on random port
\&  my $id = Mojo::IOLoop\->server({address => \*(Aq127.0.0.1\*(Aq} => sub {
\&    my ($loop, $stream, $id) = @_;
\&    ...
\&  });
\&  my $port = Mojo::IOLoop\->acceptor($id)\->handle\->sockport;
.Ve
.SS "singleton"
.IX Subsection "singleton"
.Vb 1
\&  my $loop = Mojo::IOLoop\->singleton;
.Ve
.PP
The global Mojo::IOLoop singleton, used to access a single shared event
loop object from everywhere inside the process.
.PP
.Vb 3
\&  # Many methods also allow you to take shortcuts
\&  Mojo::IOLoop\->timer(2 => sub { Mojo::IOLoop\->stop });
\&  Mojo::IOLoop\->start;
\&
\&  # Restart active timer
\&  my $id = Mojo::IOLoop\->timer(3 => sub { say \*(AqTimeout!\*(Aq });
\&  Mojo::IOLoop\->singleton\->reactor\->again($id);
.Ve
.SS "start"
.IX Subsection "start"
.Vb 2
\&  Mojo::IOLoop\->start;
\&  $loop\->start;
.Ve
.PP
Start the event loop, this will block until \*(L"stop\*(R" is called. Note that
some reactors stop automatically if there are no events being watched anymore.
.PP
.Vb 2
\&  # Start event loop only if it is not running already
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "stop"
.IX Subsection "stop"
.Vb 2
\&  Mojo::IOLoop\->stop;
\&  $loop\->stop;
.Ve
.PP
Stop the event loop, this will not interrupt any existing connections and the
event loop can be restarted by running \*(L"start\*(R" again.
.SS "stream"
.IX Subsection "stream"
.Vb 3
\&  my $stream = Mojo::IOLoop\->stream($id);
\&  my $stream = $loop\->stream($id);
\&  my $id     = $loop\->stream(Mojo::IOLoop::Stream\->new);
.Ve
.PP
Get Mojo::IOLoop::Stream object for id or turn object into a connection.
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  Mojo::IOLoop\->stream($id)\->timeout(300);
.Ve
.SS "timer"
.IX Subsection "timer"
.Vb 3
\&  my $id = Mojo::IOLoop\->timer(3 => sub {...});
\&  my $id = $loop\->timer(0 => sub {...});
\&  my $id = $loop\->timer(0.25 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds.
.PP
.Vb 5
\&  # Perform operation in 5 seconds
\&  Mojo::IOLoop\->timer(5 => sub {
\&    my $loop = shift;
\&    ...
\&  });
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`MOJO_IOLOOP_DEBUG\*(C'\fR environment variable to get some advanced
diagnostics information printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_IOLOOP_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
