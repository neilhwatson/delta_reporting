.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.30)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojolicious::Controller 3"
.TH Mojolicious::Controller 3 "2015-07-08" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Controller \- Controller base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # Controller
\&  package MyApp::Controller::Foo;
\&  use Mojo::Base \*(AqMojolicious::Controller\*(Aq;
\&
\&  # Action
\&  sub bar {
\&    my $self = shift;
\&    my $name = $self\->param(\*(Aqname\*(Aq);
\&    $self\->res\->headers\->cache_control(\*(Aqmax\-age=1, no\-cache\*(Aq);
\&    $self\->render(json => {hello => $name});
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojolicious::Controller is the base class for your Mojolicious
controllers. It is also the default controller class unless you set
\&\*(L"controller_class\*(R" in Mojolicious.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojolicious::Controller inherits all attributes from Mojo::Base and
implements the following new ones.
.SS "app"
.IX Subsection "app"
.Vb 2
\&  my $app = $c\->app;
\&  $c      = $c\->app(Mojolicious\->new);
.Ve
.PP
A reference back to the application that dispatched to this controller, usually
a Mojolicious object.
.PP
.Vb 2
\&  # Use application logger
\&  $c\->app\->log\->debug(\*(AqHello Mojo\*(Aq);
\&
\&  # Generate path
\&  my $path = $c\->app\->home\->rel_file(\*(Aqtemplates/foo/bar.html.ep\*(Aq);
.Ve
.SS "match"
.IX Subsection "match"
.Vb 2
\&  my $m = $c\->match;
\&  $c    = $c\->match(Mojolicious::Routes::Match\->new);
.Ve
.PP
Router results for the current request, defaults to a
Mojolicious::Routes::Match object.
.PP
.Vb 3
\&  # Introspect
\&  my $controller = $c\->match\->endpoint\->pattern\->defaults\->{controller};
\&  my $action     = $c\->match\->stack\->[\-1]{action};
.Ve
.SS "tx"
.IX Subsection "tx"
.Vb 2
\&  my $tx = $c\->tx;
\&  $c     = $c\->tx(Mojo::Transaction::HTTP\->new);
.Ve
.PP
The transaction that is currently being processed, usually a
Mojo::Transaction::HTTP or Mojo::Transaction::WebSocket object. Note that
this reference is usually weakened, so the object needs to be referenced
elsewhere as well when you're performing non-blocking operations and the
underlying connection might get closed early.
.PP
.Vb 3
\&  # Check peer information
\&  my $address = $c\->tx\->remote_address;
\&  my $port    = $c\->tx\->remote_port;
\&
\&  # Increase size limit for WebSocket messages to 16MB
\&  $c\->tx\->max_websocket_size(16777216) if $c\->tx\->is_websocket;
\&
\&  # Perform non\-blocking operation without knowing the connection status
\&  my $tx = $c\->tx;
\&  Mojo::IOLoop\->timer(2 => sub {
\&    $c\->app\->log\->debug($tx\->is_finished ? \*(AqFinished\*(Aq : \*(AqIn progress\*(Aq);
\&  });
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojolicious::Controller inherits all methods from Mojo::Base and
implements the following new ones.
.SS "continue"
.IX Subsection "continue"
.Vb 1
\&  $c\->continue;
.Ve
.PP
Continue dispatch chain from an intermediate destination with
\&\*(L"continue\*(R" in Mojolicious::Routes.
.SS "cookie"
.IX Subsection "cookie"
.Vb 3
\&  my $value = $c\->cookie(\*(Aqfoo\*(Aq);
\&  $c        = $c\->cookie(foo => \*(Aqbar\*(Aq);
\&  $c        = $c\->cookie(foo => \*(Aqbar\*(Aq, {path => \*(Aq/\*(Aq});
.Ve
.PP
Access request cookie values and create new response cookies. If there are
multiple values sharing the same name, and you want to access more than just
the last one, you can use \*(L"every_cookie\*(R".
.PP
.Vb 2
\&  # Create response cookie with domain and expiration date
\&  $c\->cookie(user => \*(Aqsri\*(Aq, {domain => \*(Aqexample.com\*(Aq, expires => time + 60});
\&
\&  # Create secure response cookie
\&  $c\->cookie(secret => \*(AqI <3 Mojolicious\*(Aq, {secure => 1, httponly => 1});
.Ve
.SS "every_cookie"
.IX Subsection "every_cookie"
.Vb 1
\&  my $values = $c\->every_cookie(\*(Aqfoo\*(Aq);
.Ve
.PP
Similar to \*(L"cookie\*(R", but returns all request cookie values sharing the same
name as an array reference.
.PP
.Vb 2
\&  $ Get first cookie value
\&  my $first = $c\->every_cookie(\*(Aqfoo\*(Aq)\->[0];
.Ve
.SS "every_param"
.IX Subsection "every_param"
.Vb 1
\&  my $values = $c\->every_param(\*(Aqfoo\*(Aq);
.Ve
.PP
Similar to \*(L"param\*(R", but returns all values sharing the same name as an
array reference.
.PP
.Vb 2
\&  # Get first value
\&  my $first = $c\->every_param(\*(Aqfoo\*(Aq)\->[0];
.Ve
.SS "every_signed_cookie"
.IX Subsection "every_signed_cookie"
.Vb 1
\&  my $values = $c\->every_signed_cookie(\*(Aqfoo\*(Aq);
.Ve
.PP
Similar to \*(L"signed_cookie\*(R", but returns all signed request cookie values
sharing the same name as an array reference.
.PP
.Vb 2
\&  # Get first signed cookie value
\&  my $first = $c\->every_signed_cookie(\*(Aqfoo\*(Aq)\->[0];
.Ve
.SS "finish"
.IX Subsection "finish"
.Vb 4
\&  $c = $c\->finish;
\&  $c = $c\->finish(1000);
\&  $c = $c\->finish(1003 => \*(AqCannot accept data!\*(Aq);
\&  $c = $c\->finish(\*(AqBye!\*(Aq);
.Ve
.PP
Close WebSocket connection or long poll stream gracefully. This method will
automatically respond to WebSocket handshake requests with a \f(CW101\fR response
status, to establish the WebSocket connection.
.SS "flash"
.IX Subsection "flash"
.Vb 3
\&  my $foo = $c\->flash(\*(Aqfoo\*(Aq);
\&  $c      = $c\->flash({foo => \*(Aqbar\*(Aq});
\&  $c      = $c\->flash(foo => \*(Aqbar\*(Aq);
.Ve
.PP
Data storage persistent only for the next request, stored in the \*(L"session\*(R".
.PP
.Vb 3
\&  # Show message after redirect
\&  $c\->flash(message => \*(AqUser created successfully!\*(Aq);
\&  $c\->redirect_to(\*(Aqshow_user\*(Aq, id => 23);
.Ve
.SS "helpers"
.IX Subsection "helpers"
.Vb 1
\&  my $helpers = $c\->helpers;
.Ve
.PP
Return a proxy object containing the current controller object and on which
helpers provided by \*(L"app\*(R" can be called. This includes all helpers from
Mojolicious::Plugin::DefaultHelpers and Mojolicious::Plugin::TagHelpers.
.PP
.Vb 2
\&  # Make sure to use the "title" helper and not the controller method
\&  $c\->helpers\->title(\*(AqWelcome!\*(Aq);
\&
\&  # Use a nested helper instead of the "reply" controller method
\&  $c\->helpers\->reply\->not_found;
.Ve
.SS "on"
.IX Subsection "on"
.Vb 1
\&  my $cb = $c\->on(finish => sub {...});
.Ve
.PP
Subscribe to events of \*(L"tx\*(R", which is usually a Mojo::Transaction::HTTP
or Mojo::Transaction::WebSocket object. This method will automatically
respond to WebSocket handshake requests with a \f(CW101\fR response status, to
establish the WebSocket connection.
.PP
.Vb 5
\&  # Do something after the transaction has been finished
\&  $c\->on(finish => sub {
\&    my $c = shift;
\&    $c\->app\->log\->debug(\*(AqWe are done\*(Aq);
\&  });
\&
\&  # Receive WebSocket message
\&  $c\->on(message => sub {
\&    my ($c, $msg) = @_;
\&    $c\->app\->log\->debug("Message: $msg");
\&  });
\&
\&  # Receive JSON object via WebSocket message
\&  $c\->on(json => sub {
\&    my ($c, $hash) = @_;
\&    $c\->app\->log\->debug("Test: $hash\->{test}");
\&  });
\&
\&  # Receive WebSocket "Binary" message
\&  $c\->on(binary => sub {
\&    my ($c, $bytes) = @_;
\&    my $len = length $bytes;
\&    $c\->app\->log\->debug("Received $len bytes");
\&  });
.Ve
.SS "param"
.IX Subsection "param"
.Vb 4
\&  my $value = $c\->param(\*(Aqfoo\*(Aq);
\&  $c        = $c\->param(foo => \*(Aqba;r\*(Aq);
\&  $c        = $c\->param(foo => qw(ba;r baz));
\&  $c        = $c\->param(foo => [\*(Aqba;r\*(Aq, \*(Aqbaz\*(Aq]);
.Ve
.PP
Access route placeholder values that are not reserved stash values, file
uploads as well as \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR parameters extracted from the query
string and \f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR or \f(CW\*(C`multipart/form\-data\*(C'\fR
message body, in that order. If there are multiple values sharing the same
name, and you want to access more than just the last one, you can use
\&\*(L"every_param\*(R". Parts of the request body need to be loaded into memory to
parse \f(CW\*(C`POST\*(C'\fR parameters, so you have to make sure it is not excessively large,
there's a 16MB limit by default.
.PP
.Vb 2
\&  # Get first value
\&  my $first = $c\->every_param(\*(Aqfoo\*(Aq)\->[0];
.Ve
.PP
For more control you can also access request information directly.
.PP
.Vb 2
\&  # Only GET parameters
\&  my $foo = $c\->req\->query_params\->param(\*(Aqfoo\*(Aq);
\&
\&  # Only POST parameters
\&  my $foo = $c\->req\->body_params\->param(\*(Aqfoo\*(Aq);
\&
\&  # Only GET and POST parameters
\&  my $foo = $c\->req\->param(\*(Aqfoo\*(Aq);
\&
\&  # Only file uploads
\&  my $foo = $c\->req\->upload(\*(Aqfoo\*(Aq);
.Ve
.SS "redirect_to"
.IX Subsection "redirect_to"
.Vb 4
\&  $c = $c\->redirect_to(\*(Aqnamed\*(Aq, foo => \*(Aqbar\*(Aq);
\&  $c = $c\->redirect_to(\*(Aqnamed\*(Aq, {foo => \*(Aqbar\*(Aq});
\&  $c = $c\->redirect_to(\*(Aq/index.html\*(Aq);
\&  $c = $c\->redirect_to(\*(Aqhttp://example.com/index.html\*(Aq);
.Ve
.PP
Prepare a \f(CW302\fR redirect response, takes the same arguments as \*(L"url_for\*(R".
.PP
.Vb 3
\&  # Moved permanently
\&  $c\->res\->code(301);
\&  $c\->redirect_to(\*(Aqsome_route\*(Aq);
.Ve
.SS "render"
.IX Subsection "render"
.Vb 9
\&  my $bool = $c\->render;
\&  my $bool = $c\->render(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&  my $bool = $c\->render(template => \*(Aqfoo/index\*(Aq);
\&  my $bool = $c\->render(template => \*(Aqindex\*(Aq, format => \*(Aqhtml\*(Aq);
\&  my $bool = $c\->render(data => $bytes);
\&  my $bool = $c\->render(text => \*(AqHello!\*(Aq);
\&  my $bool = $c\->render(json => {foo => \*(Aqbar\*(Aq});
\&  my $bool = $c\->render(handler => \*(Aqsomething\*(Aq);
\&  my $bool = $c\->render(\*(Aqfoo/index\*(Aq);
.Ve
.PP
Render content with \*(L"renderer\*(R" in Mojolicious and emit hooks
\&\*(L"before_render\*(R" in Mojolicious as well as \*(L"after_render\*(R" in Mojolicious, or
call \*(L"reply\->not_found\*(R" in Mojolicious::Plugin::DefaultHelpers if no
response could be generated, all additional key/value pairs get merged into the
\&\*(L"stash\*(R".
.PP
.Vb 2
\&  # Render characters
\&  $c\->render(text => \*(AqI ♥ Mojolicious!\*(Aq);
\&
\&  # Render characters (alternative)
\&  $c\->stash(text => \*(AqI ♥ Mojolicious!\*(Aq)\->render;
\&
\&  # Render binary data
\&  use Mojo::JSON \*(Aqencode_json\*(Aq;
\&  $c\->render(data => encode_json({test => \*(AqI ♥ Mojolicious!\*(Aq}));
\&
\&  # Render JSON
\&  $c\->render(json => {test => \*(AqI ♥ Mojolicious!\*(Aq});
\&
\&  # Render inline template
\&  $c\->render(inline => \*(Aq<%= 1 + 1 %>\*(Aq);
\&
\&  # Render template "foo/bar.html.ep"
\&  $c\->render(template => \*(Aqfoo/bar\*(Aq, format => \*(Aqhtml\*(Aq, handler => \*(Aqep\*(Aq);
\&
\&  # Render template "test.*.*" with arbitrary values "foo" and "bar"
\&  $c\->render(template => \*(Aqtest\*(Aq, foo => \*(Aqtest\*(Aq, bar => 23);
\&
\&  # Render template "test.xml.*"
\&  $c\->render(template => \*(Aqtest\*(Aq, format => \*(Aqxml\*(Aq);
\&
\&  # Render template "test.xml.*" (alternative)
\&  $c\->render(\*(Aqtest\*(Aq, format => \*(Aqxml\*(Aq);
.Ve
.SS "render_later"
.IX Subsection "render_later"
.Vb 1
\&  $c = $c\->render_later;
.Ve
.PP
Disable automatic rendering to delay response generation, only necessary if
automatic rendering would result in a response.
.PP
.Vb 5
\&  # Delayed rendering
\&  $c\->render_later;
\&  Mojo::IOLoop\->timer(2 => sub {
\&    $c\->render(text => \*(AqDelayed by 2 seconds!\*(Aq);
\&  });
.Ve
.SS "render_maybe"
.IX Subsection "render_maybe"
.Vb 3
\&  my $bool = $c\->render_maybe;
\&  my $bool = $c\->render_maybe(controller => \*(Aqfoo\*(Aq, action => \*(Aqbar\*(Aq);
\&  my $bool = $c\->render_maybe(\*(Aqfoo/index\*(Aq, format => \*(Aqhtml\*(Aq);
.Ve
.PP
Try to render content, but do not call
\&\*(L"reply\->not_found\*(R" in Mojolicious::Plugin::DefaultHelpers if no response
could be generated, takes the same arguments as \*(L"render\*(R".
.PP
.Vb 2
\&  # Render template "index_local" only if it exists
\&  $c\->render_maybe(\*(Aqindex_local\*(Aq) or $c\->render(\*(Aqindex\*(Aq);
.Ve
.SS "render_to_string"
.IX Subsection "render_to_string"
.Vb 1
\&  my $output = $c\->render_to_string(\*(Aqfoo/index\*(Aq, format => \*(Aqpdf\*(Aq);
.Ve
.PP
Try to render content and return it wrapped in a Mojo::ByteStream object or
return \f(CW\*(C`undef\*(C'\fR, all arguments get localized automatically and are only
available during this render operation, takes the same arguments as
\&\*(L"render\*(R".
.PP
.Vb 2
\&  # Render inline template
\&  my $two = $c\->render_to_string(inline => \*(Aq<%= 1 + 1 %>\*(Aq);
.Ve
.SS "rendered"
.IX Subsection "rendered"
.Vb 2
\&  $c = $c\->rendered;
\&  $c = $c\->rendered(302);
.Ve
.PP
Finalize response and emit hook \*(L"after_dispatch\*(R" in Mojolicious, defaults to
using a \f(CW200\fR response code.
.PP
.Vb 4
\&  # Custom response
\&  $c\->res\->headers\->content_type(\*(Aqtext/plain\*(Aq);
\&  $c\->res\->body(\*(AqHello World!\*(Aq);
\&  $c\->rendered(200);
.Ve
.SS "req"
.IX Subsection "req"
.Vb 1
\&  my $req = $c\->req;
.Ve
.PP
Get Mojo::Message::Request object from \*(L"tx\*(R".
.PP
.Vb 2
\&  # Longer version
\&  my $req = $c\->tx\->req;
\&
\&  # Extract request information
\&  my $url   = $c\->req\->url\->to_abs;
\&  my $info  = $c\->req\->url\->to_abs\->userinfo;
\&  my $host  = $c\->req\->url\->to_abs\->host;
\&  my $agent = $c\->req\->headers\->user_agent;
\&  my $bytes = $c\->req\->body;
\&  my $str   = $c\->req\->text;
\&  my $hash  = $c\->req\->params\->to_hash;
\&  my $value = $c\->req\->json;
\&  my $foo   = $c\->req\->json(\*(Aq/23/foo\*(Aq);
\&  my $dom   = $c\->req\->dom;
\&  my $bar   = $c\->req\->dom(\*(Aqdiv.bar\*(Aq)\->first\->text;
.Ve
.SS "res"
.IX Subsection "res"
.Vb 1
\&  my $res = $c\->res;
.Ve
.PP
Get Mojo::Message::Response object from \*(L"tx\*(R".
.PP
.Vb 2
\&  # Longer version
\&  my $res = $c\->tx\->res;
\&
\&  # Force file download by setting a custom response header
\&  $c\->res\->headers\->content_disposition(\*(Aqattachment; filename=foo.png;\*(Aq);
\&
\&  # Make sure response is cached correctly
\&  $c\->res\->headers\->cache_control(\*(Aqpublic, max\-age=300\*(Aq);
\&  $c\->res\->headers\->append(Vary => \*(AqAccept\-Encoding\*(Aq);
.Ve
.SS "respond_to"
.IX Subsection "respond_to"
.Vb 5
\&  $c = $c\->respond_to(
\&    json => {json => {message => \*(AqWelcome!\*(Aq}},
\&    html => {template => \*(Aqwelcome\*(Aq},
\&    any  => sub {...}
\&  );
.Ve
.PP
Automatically select best possible representation for resource from \f(CW\*(C`Accept\*(C'\fR
request header, \f(CW\*(C`format\*(C'\fR stash value or \f(CW\*(C`format\*(C'\fR \f(CW\*(C`GET\*(C'\fR/\f(CW\*(C`POST\*(C'\fR parameter,
defaults to rendering an empty \f(CW204\fR response. Each representation can be
handled with a callback or a hash reference containing arguments to be passed
to \*(L"render\*(R". Since browsers often don't really know what they actually
want, unspecific \f(CW\*(C`Accept\*(C'\fR request headers with more than one \s-1MIME\s0 type will be
ignored, unless the \f(CW\*(C`X\-Requested\-With\*(C'\fR header is set to the value
\&\f(CW\*(C`XMLHttpRequest\*(C'\fR.
.PP
.Vb 6
\&  # Everything else than "json" and "xml" gets a 204 response
\&  $c\->respond_to(
\&    json => sub { $c\->render(json => {just => \*(Aqworks\*(Aq}) },
\&    xml  => {text => \*(Aq<just>works</just>\*(Aq},
\&    any  => {data => \*(Aq\*(Aq, status => 204}
\&  );
.Ve
.PP
For more advanced negotiation logic you can also use the helper
\&\*(L"accepts\*(R" in Mojolicious::Plugin::DefaultHelpers.
.SS "send"
.IX Subsection "send"
.Vb 6
\&  $c = $c\->send({binary => $bytes});
\&  $c = $c\->send({text   => $bytes});
\&  $c = $c\->send({json   => {test => [1, 2, 3]}});
\&  $c = $c\->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
\&  $c = $c\->send($chars);
\&  $c = $c\->send($chars => sub {...});
.Ve
.PP
Send message or frame non-blocking via WebSocket, the optional drain callback
will be invoked once all data has been written. This method will automatically
respond to WebSocket handshake requests with a \f(CW101\fR response status, to
establish the WebSocket connection.
.PP
.Vb 2
\&  # Send "Text" message
\&  $c\->send(\*(AqI ♥ Mojolicious!\*(Aq);
\&
\&  # Send JSON object as "Text" message
\&  $c\->send({json => {test => \*(AqI ♥ Mojolicious!\*(Aq}});
\&
\&  # Send JSON object as "Binary" message
\&  use Mojo::JSON \*(Aqencode_json\*(Aq;
\&  $c\->send({binary => encode_json({test => \*(AqI ♥ Mojolicious!\*(Aq})});
\&
\&  # Send "Ping" frame
\&  $c\->send([1, 0, 0, 0, 9, \*(AqHello World!\*(Aq]);
\&
\&  # Make sure previous message has been written before continuing
\&  $c\->send(\*(AqFirst message!\*(Aq => sub {
\&    my $c = shift;
\&    $c\->send(\*(AqSecond message!\*(Aq);
\&  });
.Ve
.PP
For mostly idle WebSockets you might also want to increase the inactivity
timeout with \*(L"inactivity_timeout\*(R" in Mojolicious::Plugin::DefaultHelpers, which
usually defaults to \f(CW15\fR seconds.
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  $c\->inactivity_timeout(300);
.Ve
.SS "session"
.IX Subsection "session"
.Vb 4
\&  my $session = $c\->session;
\&  my $foo     = $c\->session(\*(Aqfoo\*(Aq);
\&  $c          = $c\->session({foo => \*(Aqbar\*(Aq});
\&  $c          = $c\->session(foo => \*(Aqbar\*(Aq);
.Ve
.PP
Persistent data storage for the next few requests, all session data gets
serialized with Mojo::JSON and stored Base64 encoded in \s-1HMAC\-SHA1\s0 signed
cookies, to prevent tampering. Note that cookies usually have a \f(CW4096\fR byte
(4KB) limit, depending on browser.
.PP
.Vb 4
\&  # Manipulate session
\&  $c\->session\->{foo} = \*(Aqbar\*(Aq;
\&  my $foo = $c\->session\->{foo};
\&  delete $c\->session\->{foo};
\&
\&  # Expiration date in seconds from now (persists between requests)
\&  $c\->session(expiration => 604800);
\&
\&  # Expiration date as absolute epoch time (only valid for one request)
\&  $c\->session(expires => time + 604800);
\&
\&  # Delete whole session by setting an expiration date in the past
\&  $c\->session(expires => 1);
.Ve
.SS "signed_cookie"
.IX Subsection "signed_cookie"
.Vb 3
\&  my $value = $c\->signed_cookie(\*(Aqfoo\*(Aq);
\&  $c        = $c\->signed_cookie(foo => \*(Aqbar\*(Aq);
\&  $c        = $c\->signed_cookie(foo => \*(Aqbar\*(Aq, {path => \*(Aq/\*(Aq});
.Ve
.PP
Access signed request cookie values and create new signed response cookies. If
there are multiple values sharing the same name, and you want to access more
than just the last one, you can use \*(L"every_signed_cookie\*(R". Cookies are
cryptographically signed with \s-1HMAC\-SHA1,\s0 to prevent tampering, and the ones
failing signature verification will be automatically discarded.
.SS "stash"
.IX Subsection "stash"
.Vb 4
\&  my $hash = $c\->stash;
\&  my $foo  = $c\->stash(\*(Aqfoo\*(Aq);
\&  $c       = $c\->stash({foo => \*(Aqbar\*(Aq});
\&  $c       = $c\->stash(foo => \*(Aqbar\*(Aq);
.Ve
.PP
Non-persistent data storage and exchange for the current request, application
wide default values can be set with \*(L"defaults\*(R" in Mojolicious. Some stash
values have a special meaning and are reserved, the full list is currently
\&\f(CW\*(C`action\*(C'\fR, \f(CW\*(C`app\*(C'\fR, \f(CW\*(C`cb\*(C'\fR, \f(CW\*(C`controller\*(C'\fR, \f(CW\*(C`data\*(C'\fR, \f(CW\*(C`extends\*(C'\fR, \f(CW\*(C`format\*(C'\fR,
\&\f(CW\*(C`handler\*(C'\fR, \f(CW\*(C`inline\*(C'\fR, \f(CW\*(C`json\*(C'\fR, \f(CW\*(C`layout\*(C'\fR, \f(CW\*(C`namespace\*(C'\fR, \f(CW\*(C`path\*(C'\fR, \f(CW\*(C`status\*(C'\fR,
\&\f(CW\*(C`template\*(C'\fR, \f(CW\*(C`text\*(C'\fR and \f(CW\*(C`variant\*(C'\fR. Note that all stash values with a
\&\f(CW\*(C`mojo.*\*(C'\fR prefix are reserved for internal use.
.PP
.Vb 2
\&  # Remove value
\&  my $foo = delete $c\->stash\->{foo};
\&
\&  # Assign multiple values at once
\&  $c\->stash(foo => \*(Aqtest\*(Aq, bar => 23);
.Ve
.SS "url_for"
.IX Subsection "url_for"
.Vb 9
\&  my $url = $c\->url_for;
\&  my $url = $c\->url_for(name => \*(Aqsebastian\*(Aq);
\&  my $url = $c\->url_for({name => \*(Aqsebastian\*(Aq});
\&  my $url = $c\->url_for(\*(Aqtest\*(Aq, name => \*(Aqsebastian\*(Aq);
\&  my $url = $c\->url_for(\*(Aqtest\*(Aq, {name => \*(Aqsebastian\*(Aq});
\&  my $url = $c\->url_for(\*(Aq/index.html\*(Aq);
\&  my $url = $c\->url_for(\*(Aq//example.com/index.html\*(Aq);
\&  my $url = $c\->url_for(\*(Aqhttp://example.com/index.html\*(Aq);
\&  my $url = $c\->url_for(\*(Aqmailto:sri@example.com\*(Aq);
.Ve
.PP
Generate a portable Mojo::URL object with base for a path, \s-1URL\s0 or route.
.PP
.Vb 2
\&  # "http://127.0.0.1:3000/index.html" if application was started with Morbo
\&  $c\->url_for(\*(Aq/index.html\*(Aq)\->to_abs;
\&
\&  # "https://127.0.0.1:443/index.html" if application was started with Morbo
\&  $c\->url_for(\*(Aq/index.html\*(Aq)\->to_abs\->scheme(\*(Aqhttps\*(Aq)\->port(443);
\&
\&  # "/index.html?foo=bar" if application is deployed under "/"
\&  $c\->url_for(\*(Aq/index.html\*(Aq)\->query(foo => \*(Aqbar\*(Aq);
\&
\&  # "/myapp/index.html?foo=bar" if application is deployed under "/myapp"
\&  $c\->url_for(\*(Aq/index.html\*(Aq)\->query(foo => \*(Aqbar\*(Aq);
.Ve
.PP
You can also use the helper \*(L"url_with\*(R" in Mojolicious::Plugin::DefaultHelpers
to inherit query parameters from the current request.
.PP
.Vb 2
\&  # "/list?q=mojo&page=2" if current request was for "/list?q=mojo&page=1"
\&  $c\->url_with\->query([page => 2]);
.Ve
.SS "validation"
.IX Subsection "validation"
.Vb 1
\&  my $validation = $c\->validation;
.Ve
.PP
Get Mojolicious::Validator::Validation object for current request to
validate file uploads as well as \f(CW\*(C`GET\*(C'\fR and \f(CW\*(C`POST\*(C'\fR parameters extracted from
the query string and \f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR or
\&\f(CW\*(C`multipart/form\-data\*(C'\fR message body. Parts of the request body need to be loaded
into memory to parse \f(CW\*(C`POST\*(C'\fR parameters, so you have to make sure it is not
excessively large, there's a 16MB limit by default.
.PP
.Vb 4
\&  # Validate GET/POST parameter
\&  my $validation = $c\->validation;
\&  $validation\->required(\*(Aqtitle\*(Aq)\->size(3, 50);
\&  my $title = $validation\->param(\*(Aqtitle\*(Aq);
\&
\&  # Validate file upload
\&  my $validation = $c\->validation;
\&  $validation\->required(\*(Aqtarball\*(Aq)\->upload\->size(1, 1048576);
\&  my $tarball = $validation\->param(\*(Aqtarball\*(Aq);
.Ve
.SS "write"
.IX Subsection "write"
.Vb 5
\&  $c = $c\->write;
\&  $c = $c\->write(\*(Aq\*(Aq);
\&  $c = $c\->write($bytes);
\&  $c = $c\->write(sub {...});
\&  $c = $c\->write($bytes => sub {...});
.Ve
.PP
Write dynamic content non-blocking, the optional drain callback will be invoked
once all data has been written. Calling this method without a chunk of data
will finalize the response headers and allow for dynamic content to be written
later.
.PP
.Vb 6
\&  # Keep connection alive (with Content\-Length header)
\&  $c\->res\->headers\->content_length(6);
\&  $c\->write(\*(AqHel\*(Aq => sub {
\&    my $c = shift;
\&    $c\->write(\*(Aqlo!\*(Aq);
\&  });
\&
\&  # Close connection when finished (without Content\-Length header)
\&  $c\->write(\*(AqHel\*(Aq => sub {
\&    my $c = shift;
\&    $c\->write(\*(Aqlo!\*(Aq => sub {
\&      my $c = shift;
\&      $c\->finish;
\&    });
\&  });
.Ve
.PP
You can call \*(L"finish\*(R" or write an empty chunk of data at any time to end
the stream.
.PP
.Vb 5
\&  HTTP/1.1 200 OK
\&  Connection: keep\-alive
\&  Date: Sat, 13 Sep 2014 16:48:29 GMT
\&  Content\-Length: 6
\&  Server: Mojolicious (Perl)
\&
\&  Hello!
\&
\&  HTTP/1.1 200 OK
\&  Connection: close
\&  Date: Sat, 13 Sep 2014 16:48:29 GMT
\&  Server: Mojolicious (Perl)
\&
\&  Hello!
.Ve
.PP
For Comet (long polling) you might also want to increase the inactivity timeout
with \*(L"inactivity_timeout\*(R" in Mojolicious::Plugin::DefaultHelpers, which usually
defaults to \f(CW15\fR seconds.
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  $c\->inactivity_timeout(300);
.Ve
.SS "write_chunk"
.IX Subsection "write_chunk"
.Vb 5
\&  $c = $c\->write_chunk;
\&  $c = $c\->write_chunk(\*(Aq\*(Aq);
\&  $c = $c\->write_chunk($bytes);
\&  $c = $c\->write_chunk(sub {...});
\&  $c = $c\->write_chunk($bytes => sub {...});
.Ve
.PP
Write dynamic content non-blocking with \f(CW\*(C`chunked\*(C'\fR transfer encoding, the
optional drain callback will be invoked once all data has been written. Calling
this method without a chunk of data will finalize the response headers and
allow for dynamic content to be written later.
.PP
.Vb 8
\&  # Make sure previous chunk has been written before continuing
\&  $c\->write_chunk(\*(AqH\*(Aq => sub {
\&    my $c = shift;
\&    $c\->write_chunk(\*(Aqell\*(Aq => sub {
\&      my $c = shift;
\&      $c\->finish(\*(Aqo!\*(Aq);
\&    });
\&  });
.Ve
.PP
You can call \*(L"finish\*(R" or write an empty chunk of data at any time to end
the stream.
.PP
.Vb 5
\&  HTTP/1.1 200 OK
\&  Connection: keep\-alive
\&  Date: Sat, 13 Sep 2014 16:48:29 GMT
\&  Transfer\-Encoding: chunked
\&  Server: Mojolicious (Perl)
\&
\&  1
\&  H
\&  3
\&  ell
\&  2
\&  o!
\&  0
.Ve
.SH "AUTOLOAD"
.IX Header "AUTOLOAD"
In addition to the \*(L"\s-1ATTRIBUTES\*(R"\s0 and \*(L"\s-1METHODS\*(R"\s0 above you can also call
helpers provided by \*(L"app\*(R" on Mojolicious::Controller objects. This
includes all helpers from Mojolicious::Plugin::DefaultHelpers and
Mojolicious::Plugin::TagHelpers.
.PP
.Vb 3
\&  # Call helpers
\&  $c\->layout(\*(Aqgreen\*(Aq);
\&  $c\->title(\*(AqWelcome!\*(Aq);
\&
\&  # Longer version
\&  $c\->helpers\->layout(\*(Aqgreen\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
